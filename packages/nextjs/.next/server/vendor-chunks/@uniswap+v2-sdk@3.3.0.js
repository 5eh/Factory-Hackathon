"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@uniswap+v2-sdk@3.3.0";
exports.ids = ["vendor-chunks/@uniswap+v2-sdk@3.3.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@uniswap+v2-sdk@3.3.0/node_modules/@uniswap/v2-sdk/dist/v2-sdk.esm.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@uniswap+v2-sdk@3.3.0/node_modules/@uniswap/v2-sdk/dist/v2-sdk.esm.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FACTORY_ADDRESS_MAP: () => (/* binding */ FACTORY_ADDRESS_MAP),\n/* harmony export */   INIT_CODE_HASH: () => (/* binding */ INIT_CODE_HASH),\n/* harmony export */   InsufficientInputAmountError: () => (/* binding */ InsufficientInputAmountError),\n/* harmony export */   InsufficientReservesError: () => (/* binding */ InsufficientReservesError),\n/* harmony export */   MINIMUM_LIQUIDITY: () => (/* binding */ MINIMUM_LIQUIDITY),\n/* harmony export */   Pair: () => (/* binding */ Pair),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   Trade: () => (/* binding */ Trade),\n/* harmony export */   computePairAddress: () => (/* binding */ computePairAddress),\n/* harmony export */   inputOutputComparator: () => (/* binding */ inputOutputComparator),\n/* harmony export */   tradeComparator: () => (/* binding */ tradeComparator)\n/* harmony export */ });\n/* harmony import */ var _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uniswap/sdk-core */ \"(ssr)/./node_modules/.pnpm/@uniswap+sdk-core@4.2.1/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js\");\n/* harmony import */ var jsbi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsbi */ \"(ssr)/./node_modules/.pnpm/jsbi@3.2.5/node_modules/jsbi/dist/jsbi.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/.pnpm/tiny-invariant@1.3.3/node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/solidity */ \"(ssr)/./node_modules/.pnpm/@ethersproject+solidity@5.7.0/node_modules/@ethersproject/solidity/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n\n\n\n\n\n\n\nvar FACTORY_ADDRESS_MAP = {\n  // Mainnet\n  1: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f',\n  // Ropsten\n  3: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f',\n  // Goerli\n  5: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f',\n  // Optimism\n  10: '0x0c3c1c532F1e39EdF36BE9Fe0bE1410313E074Bf',\n  // Arbitrum\n  42161: '0xf1D7CC64Fb4452F05c498126312eBE29f30Fbcf9',\n  // Avalanche\n  43114: '0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C',\n  // Base\n  8453: '0x8909dc15e40173ff4699343b6eb8132c65e18ec6',\n  // BNB\n  56: '0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6',\n  // Polygon\n  137: '0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C'\n};\nvar INIT_CODE_HASH = '0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f';\nvar MINIMUM_LIQUIDITY = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(1000); // exports for internal consumption\n\nvar ZERO = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(0);\nvar ONE = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(1);\nvar FIVE = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(5);\nvar _997 = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(997);\nvar _1000 = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(1000);\nvar BASIS_POINTS = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(10000);\nvar ZERO_PERCENT = /*#__PURE__*/new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Percent(ZERO);\nvar ONE_HUNDRED_PERCENT = /*#__PURE__*/new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Percent(ONE);\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\n// see https://stackoverflow.com/a/41102306\nvar CAN_SET_PROTOTYPE = ('setPrototypeOf' in Object);\n/**\r\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\r\n * obtained by sending any amount of input.\r\n */\n\nvar InsufficientReservesError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(InsufficientReservesError, _Error);\n\n  function InsufficientReservesError() {\n    var _this;\n\n    _this = _Error.call(this) || this;\n    _this.isInsufficientReservesError = true;\n    _this.name = _this.constructor.name;\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof InsufficientReservesError ? this.constructor : void 0).prototype);\n    return _this;\n  }\n\n  return InsufficientReservesError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\r\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\r\n * than the price of a single unit of output after fees.\r\n */\n\nvar InsufficientInputAmountError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(InsufficientInputAmountError, _Error2);\n\n  function InsufficientInputAmountError() {\n    var _this2;\n\n    _this2 = _Error2.call(this) || this;\n    _this2.isInsufficientInputAmountError = true;\n    _this2.name = _this2.constructor.name;\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(_assertThisInitialized(_this2), (this instanceof InsufficientInputAmountError ? this.constructor : void 0).prototype);\n    return _this2;\n  }\n\n  return InsufficientInputAmountError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar computePairAddress = function computePairAddress(_ref) {\n  var factoryAddress = _ref.factoryAddress,\n      tokenA = _ref.tokenA,\n      tokenB = _ref.tokenB;\n\n  var _ref2 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],\n      token0 = _ref2[0],\n      token1 = _ref2[1]; // does safety checks\n\n\n  return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_3__.getCreate2Address)(factoryAddress, (0,_ethersproject_solidity__WEBPACK_IMPORTED_MODULE_4__.keccak256)(['bytes'], [(0,_ethersproject_solidity__WEBPACK_IMPORTED_MODULE_4__.pack)(['address', 'address'], [token0.address, token1.address])]), INIT_CODE_HASH);\n};\nvar Pair = /*#__PURE__*/function () {\n  function Pair(currencyAmountA, tokenAmountB) {\n    var tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n    ? [currencyAmountA, tokenAmountB] : [tokenAmountB, currencyAmountA];\n    this.liquidityToken = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Token(tokenAmounts[0].currency.chainId, Pair.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency), 18, 'UNI-V2', 'Uniswap V2');\n    this.tokenAmounts = tokenAmounts;\n  }\n\n  Pair.getAddress = function getAddress(tokenA, tokenB) {\n    return computePairAddress({\n      factoryAddress: FACTORY_ADDRESS_MAP[tokenA.chainId],\n      tokenA: tokenA,\n      tokenB: tokenB\n    });\n  }\n  /**\r\n   * Returns true if the token is either token0 or token1\r\n   * @param token to check\r\n   */\n  ;\n\n  var _proto = Pair.prototype;\n\n  _proto.involvesToken = function involvesToken(token) {\n    return token.equals(this.token0) || token.equals(this.token1);\n  }\n  /**\r\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\r\n   */\n  ;\n\n  /**\r\n   * Return the price of the given token in terms of the other token in the pair.\r\n   * @param token token to return price of\r\n   */\n  _proto.priceOf = function priceOf(token) {\n    !this.involvesToken(token) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n    return token.equals(this.token0) ? this.token0Price : this.token1Price;\n  }\n  /**\r\n   * Returns the chain ID of the tokens in the pair.\r\n   */\n  ;\n\n  _proto.reserveOf = function reserveOf(token) {\n    !this.involvesToken(token) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1;\n  }\n  /**\r\n   * getAmountOut is the linear algebra of reserve ratio against amountIn:amountOut.\r\n   * https://ethereum.stackexchange.com/questions/101629/what-is-math-for-uniswap-calculates-the-amountout-and-amountin-why-997-and-1000\r\n   * has the math deduction for the reserve calculation without fee-on-transfer fees.\r\n   *\r\n   * With fee-on-transfer tax, intuitively it's just:\r\n   * inputAmountWithFeeAndTax = 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn\r\n   *                          = (1 - amountIn.sellFeesBips / 10000) * amountInWithFee\r\n   * where amountInWithFee is the amountIn after taking out the LP fees\r\n   * outputAmountWithTax = amountOut * (1 - amountOut.buyFeesBips / 10000)\r\n   *\r\n   * But we are illustrating the math deduction below to ensure that's the case.\r\n   *\r\n   * before swap A * B = K where A = reserveIn B = reserveOut\r\n   *\r\n   * after swap A' * B' = K where only k is a constant value\r\n   *\r\n   * getAmountOut\r\n   *\r\n   * A' = A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn # here 0.3% is deducted\r\n   * B' = B - amountOut * (1 - amountOut.buyFeesBips / 10000)\r\n   * amountOut = (B - B') / (1 - amountOut.buyFeesBips / 10000) # where A' * B' still is k\r\n   *           = (B - K/(A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn))\r\n   *             /\r\n   *             (1 - amountOut.buyFeesBips / 10000)\r\n   *           = (B - AB/(A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn))\r\n   *             /\r\n   *             (1 - amountOut.buyFeesBips / 10000)\r\n   *           = ((BA + B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn - AB)/(A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn))\r\n   *             /\r\n   *             (1 - amountOut.buyFeesBips / 10000)\r\n   *           = (B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn / (A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn)\r\n   *             /\r\n   *             (1 - amountOut.buyFeesBips / 10000)\r\n   * amountOut * (1 - amountOut.buyFeesBips / 10000) = (B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn\r\n   *                                                    /\r\n   *                                                    (A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn)\r\n   *\r\n   * outputAmountWithTax = (B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn\r\n   *                       /\r\n   *                       (A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn)\r\n   *                       = (B * 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn * 1000\r\n   *                       /\r\n   *                       ((A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn) * 1000)\r\n   *                     = (B * (1 - amountIn.sellFeesBips / 10000) 997 * * amountIn\r\n   *                       /\r\n   *                       (1000 * A + (1 - amountIn.sellFeesBips / 10000) * 997 * amountIn)\r\n   *                     = (B * (1 - amountIn.sellFeesBips / 10000) * inputAmountWithFee)\r\n   *                       /\r\n   *                       (1000 * A + (1 - amountIn.sellFeesBips / 10000) * inputAmountWithFee)\r\n   *                     = (B * inputAmountWithFeeAndTax)\r\n   *                       /\r\n   *                       (1000 * A + inputAmountWithFeeAndTax)\r\n   *\r\n   * inputAmountWithFeeAndTax = (1 - amountIn.sellFeesBips / 10000) * inputAmountWithFee\r\n   * outputAmountWithTax = amountOut * (1 - amountOut.buyFeesBips / 10000)\r\n   *\r\n   * @param inputAmount\r\n   * @param calculateFotFees\r\n   */\n  ;\n\n  _proto.getOutputAmount = function getOutputAmount(inputAmount, calculateFotFees) {\n    if (calculateFotFees === void 0) {\n      calculateFotFees = false;\n    }\n\n    !this.involvesToken(inputAmount.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].equal(this.reserve0.quotient, ZERO) || jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].equal(this.reserve1.quotient, ZERO)) {\n      throw new InsufficientReservesError();\n    }\n\n    var inputReserve = this.reserveOf(inputAmount.currency);\n    var outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0);\n    var percentAfterSellFees = calculateFotFees ? this.derivePercentAfterSellFees(inputAmount) : ZERO_PERCENT;\n    var inputAmountAfterTax = percentAfterSellFees.greaterThan(ZERO_PERCENT) ? _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(inputAmount.currency, percentAfterSellFees.multiply(inputAmount).quotient // fraction.quotient will round down by itself, which is desired\n    ) : inputAmount;\n    var inputAmountWithFeeAndAfterTax = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(inputAmountAfterTax.quotient, _997);\n    var numerator = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(inputAmountWithFeeAndAfterTax, outputReserve.quotient);\n    var denominator = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(inputReserve.quotient, _1000), inputAmountWithFeeAndAfterTax);\n    var outputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0, jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].divide(numerator, denominator) // JSBI.divide will round down by itself, which is desired\n    );\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].equal(outputAmount.quotient, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n\n    var percentAfterBuyFees = calculateFotFees ? this.derivePercentAfterBuyFees(outputAmount) : ZERO_PERCENT;\n    var outputAmountAfterTax = percentAfterBuyFees.greaterThan(ZERO_PERCENT) ? _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(outputAmount.currency, outputAmount.multiply(percentAfterBuyFees).quotient // fraction.quotient will round down by itself, which is desired\n    ) : outputAmount;\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].equal(outputAmountAfterTax.quotient, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n\n    return [outputAmountAfterTax, new Pair(inputReserve.add(inputAmountAfterTax), outputReserve.subtract(outputAmountAfterTax))];\n  }\n  /**\r\n   * getAmountIn is the linear algebra of reserve ratio against amountIn:amountOut.\r\n   * https://ethereum.stackexchange.com/questions/101629/what-is-math-for-uniswap-calculates-the-amountout-and-amountin-why-997-and-1000\r\n   * has the math deduction for the reserve calculation without fee-on-transfer fees.\r\n   *\r\n   * With fee-on-transfer fees, intuitively it's just:\r\n   * outputAmountWithTax = amountOut / (1 - amountOut.buyFeesBips / 10000)\r\n   * inputAmountWithTax = amountIn / (1 - amountIn.sellFeesBips / 10000) / 0.997\r\n   *\r\n   * But we are illustrating the math deduction below to ensure that's the case.\r\n   *\r\n   * before swap A * B = K where A = reserveIn B = reserveOut\r\n   *\r\n   * after swap A' * B' = K where only k is a constant value\r\n   *\r\n   * getAmountIn\r\n   *\r\n   * B' = B - amountOut * (1 - amountOut.buyFeesBips / 10000)\r\n   * A' = A + 0.997 * (1 - amountIn.sellFeesBips / 10000) * amountIn # here 0.3% is deducted\r\n   * amountIn = (A' - A) / (0.997 * (1 - amountIn.sellFeesBips / 10000))\r\n   *          = (K / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)) - A)\r\n   *            /\r\n   *            (0.997 * (1 - amountIn.sellFeesBips / 10000))\r\n   *          = (AB / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)) - A)\r\n   *            /\r\n   *            (0.997 * (1 - amountIn.sellFeesBips / 10000))\r\n   *          = ((AB - AB + A * amountOut / (1 - amountOut.buyFeesBips / 10000)) / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)))\r\n   *            /\r\n   *            (0.997 * (1 - amountIn.sellFeesBips / 10000))\r\n   *          = ((A * amountOut / (1 - amountOut.buyFeesBips / 10000)) / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)))\r\n   *            /\r\n   *            (0.997 * (1 - amountIn.sellFeesBips / 10000))\r\n   *          = ((A * 1000 * amountOut / (1 - amountOut.buyFeesBips / 10000)) / (B - amountOut / (1 - amountOut.buyFeesBips / 10000)))\r\n   *            /\r\n   *            (997 * (1 - amountIn.sellFeesBips / 10000))\r\n   *\r\n   * outputAmountWithTax = amountOut / (1 - amountOut.buyFeesBips / 10000)\r\n   * inputAmountWithTax = amountIn / (997 * (1 - amountIn.sellFeesBips / 10000))\r\n   *                    = (A * outputAmountWithTax * 1000) / ((B - outputAmountWithTax) * 997)\r\n   *\r\n   * @param outputAmount\r\n   */\n  ;\n\n  _proto.getInputAmount = function getInputAmount(outputAmount, calculateFotFees) {\n    if (calculateFotFees === void 0) {\n      calculateFotFees = false;\n    }\n\n    !this.involvesToken(outputAmount.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n    var percentAfterBuyFees = calculateFotFees ? this.derivePercentAfterBuyFees(outputAmount) : ZERO_PERCENT;\n    var outputAmountBeforeTax = percentAfterBuyFees.greaterThan(ZERO_PERCENT) ? _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(outputAmount.currency, jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(outputAmount.divide(percentAfterBuyFees).quotient, ONE) // add 1 for rounding up\n    ) : outputAmount;\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].equal(this.reserve0.quotient, ZERO) || jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].equal(this.reserve1.quotient, ZERO) || jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient) || jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].greaterThanOrEqual(outputAmountBeforeTax.quotient, this.reserveOf(outputAmount.currency).quotient)) {\n      throw new InsufficientReservesError();\n    }\n\n    var outputReserve = this.reserveOf(outputAmount.currency);\n    var inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0);\n    var numerator = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(inputReserve.quotient, outputAmountBeforeTax.quotient), _1000);\n    var denominator = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtract(outputReserve.quotient, outputAmountBeforeTax.quotient), _997);\n    var inputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0, jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].divide(numerator, denominator), ONE) // add 1 here is part of the formula, no rounding needed here, since there will not be decimal at this point\n    );\n    var percentAfterSellFees = calculateFotFees ? this.derivePercentAfterSellFees(inputAmount) : ZERO_PERCENT;\n    var inputAmountBeforeTax = percentAfterSellFees.greaterThan(ZERO_PERCENT) ? _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(inputAmount.currency, jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(inputAmount.divide(percentAfterSellFees).quotient, ONE) // add 1 for rounding up\n    ) : inputAmount;\n    return [inputAmountBeforeTax, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  };\n\n  _proto.getLiquidityMinted = function getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {\n    !totalSupply.currency.equals(this.liquidityToken) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'LIQUIDITY') : 0 : void 0;\n    var tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    !(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n    var liquidity;\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].equal(totalSupply.quotient, ZERO)) {\n      liquidity = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtract((0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.sqrt)(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)), MINIMUM_LIQUIDITY);\n    } else {\n      var amount0 = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].divide(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient);\n      var amount1 = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].divide(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient);\n      liquidity = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lessThanOrEqual(amount0, amount1) ? amount0 : amount1;\n    }\n\n    if (!jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n\n    return _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity);\n  };\n\n  _proto.getLiquidityValue = function getLiquidityValue(token, totalSupply, liquidity, feeOn, kLast) {\n    if (feeOn === void 0) {\n      feeOn = false;\n    }\n\n    !this.involvesToken(token) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n    !totalSupply.currency.equals(this.liquidityToken) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOTAL_SUPPLY') : 0 : void 0;\n    !liquidity.currency.equals(this.liquidityToken) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'LIQUIDITY') : 0 : void 0;\n    !jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lessThanOrEqual(liquidity.quotient, totalSupply.quotient) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'LIQUIDITY') : 0 : void 0;\n    var totalSupplyAdjusted;\n\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply;\n    } else {\n      !!!kLast ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'K_LAST') : 0 : void 0;\n      var kLastParsed = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(kLast);\n\n      if (!jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].equal(kLastParsed, ZERO)) {\n        var rootK = (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.sqrt)(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(this.reserve0.quotient, this.reserve1.quotient));\n        var rootKLast = (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.sqrt)(kLastParsed);\n\n        if (jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].greaterThan(rootK, rootKLast)) {\n          var numerator = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(totalSupply.quotient, jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtract(rootK, rootKLast));\n          var denominator = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(rootK, FIVE), rootKLast);\n          var feeLiquidity = jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].divide(numerator, denominator);\n          totalSupplyAdjusted = totalSupply.add(_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(this.liquidityToken, feeLiquidity));\n        } else {\n          totalSupplyAdjusted = totalSupply;\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply;\n      }\n    }\n\n    return _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(token, jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].divide(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupplyAdjusted.quotient));\n  };\n\n  _proto.derivePercentAfterSellFees = function derivePercentAfterSellFees(inputAmount) {\n    var sellFeeBips = this.token0.wrapped.equals(inputAmount.wrapped.currency) ? this.token0.wrapped.sellFeeBps : this.token1.wrapped.sellFeeBps;\n\n    if (sellFeeBips != null && sellFeeBips.gt(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__.BigNumber.from(0))) {\n      return ONE_HUNDRED_PERCENT.subtract(new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Percent(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(sellFeeBips)).divide(BASIS_POINTS));\n    } else {\n      return ZERO_PERCENT;\n    }\n  };\n\n  _proto.derivePercentAfterBuyFees = function derivePercentAfterBuyFees(outputAmount) {\n    var buyFeeBps = this.token0.wrapped.equals(outputAmount.wrapped.currency) ? this.token0.wrapped.buyFeeBps : this.token1.wrapped.buyFeeBps;\n\n    if (buyFeeBps != null && buyFeeBps.gt(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__.BigNumber.from(0))) {\n      return ONE_HUNDRED_PERCENT.subtract(new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Percent(jsbi__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BigInt(buyFeeBps)).divide(BASIS_POINTS));\n    } else {\n      return ZERO_PERCENT;\n    }\n  };\n\n  _createClass(Pair, [{\n    key: \"token0Price\",\n    get: function get() {\n      var result = this.tokenAmounts[1].divide(this.tokenAmounts[0]);\n      return new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Price(this.token0, this.token1, result.denominator, result.numerator);\n    }\n    /**\r\n     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\r\n     */\n\n  }, {\n    key: \"token1Price\",\n    get: function get() {\n      var result = this.tokenAmounts[0].divide(this.tokenAmounts[1]);\n      return new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Price(this.token1, this.token0, result.denominator, result.numerator);\n    }\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return this.token0.chainId;\n    }\n  }, {\n    key: \"token0\",\n    get: function get() {\n      return this.tokenAmounts[0].currency;\n    }\n  }, {\n    key: \"token1\",\n    get: function get() {\n      return this.tokenAmounts[1].currency;\n    }\n  }, {\n    key: \"reserve0\",\n    get: function get() {\n      return this.tokenAmounts[0];\n    }\n  }, {\n    key: \"reserve1\",\n    get: function get() {\n      return this.tokenAmounts[1];\n    }\n  }]);\n\n  return Pair;\n}();\n\nvar Route = /*#__PURE__*/function () {\n  function Route(pairs, input, output) {\n    this._midPrice = null;\n    !(pairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'PAIRS') : 0 : void 0;\n    var chainId = pairs[0].chainId;\n    !pairs.every(function (pair) {\n      return pair.chainId === chainId;\n    }) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'CHAIN_IDS') : 0 : void 0;\n    var wrappedInput = input.wrapped;\n    !pairs[0].involvesToken(wrappedInput) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INPUT') : 0 : void 0;\n    !(typeof output === 'undefined' || pairs[pairs.length - 1].involvesToken(output.wrapped)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'OUTPUT') : 0 : void 0;\n    var path = [wrappedInput];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(pairs.entries()), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          i = _step$value[0],\n          pair = _step$value[1];\n      var currentInput = path[i];\n      !(currentInput.equals(pair.token0) || currentInput.equals(pair.token1)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'PATH') : 0 : void 0;\n\n      var _output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;\n\n      path.push(_output);\n    }\n\n    this.pairs = pairs;\n    this.path = path;\n    this.input = input;\n    this.output = output;\n  }\n\n  _createClass(Route, [{\n    key: \"midPrice\",\n    get: function get() {\n      if (this._midPrice !== null) return this._midPrice;\n      var prices = [];\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.pairs.entries()), _step2; !(_step2 = _iterator2()).done;) {\n        var _step2$value = _step2.value,\n            i = _step2$value[0],\n            pair = _step2$value[1];\n        prices.push(this.path[i].equals(pair.token0) ? new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient) : new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient));\n      }\n\n      var reduced = prices.slice(1).reduce(function (accumulator, currentValue) {\n        return accumulator.multiply(currentValue);\n      }, prices[0]);\n      return this._midPrice = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Price(this.input, this.output, reduced.denominator, reduced.numerator);\n    }\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return this.pairs[0].chainId;\n    }\n  }]);\n\n  return Route;\n}();\n\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\n\nfunction inputOutputComparator(a, b) {\n  // must have same input and output token for comparison\n  !a.inputAmount.currency.equals(b.inputAmount.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INPUT_CURRENCY') : 0 : void 0;\n  !a.outputAmount.currency.equals(b.outputAmount.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'OUTPUT_CURRENCY') : 0 : void 0;\n\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0;\n    } // trade A requires less input than trade B, so A should come first\n\n\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n} // extension of the input output comparator that also considers other dimensions of the trade in ranking them\n\nfunction tradeComparator(a, b) {\n  var ioComp = inputOutputComparator(a, b);\n\n  if (ioComp !== 0) {\n    return ioComp;\n  } // consider lowest slippage next, since these are less likely to fail\n\n\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1;\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1;\n  } // finally consider the number of hops since each hop costs gas\n\n\n  return a.route.path.length - b.route.path.length;\n}\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\n\nvar Trade = /*#__PURE__*/function () {\n  function Trade(route, amount, tradeType) {\n    this.route = route;\n    this.tradeType = tradeType;\n    var tokenAmounts = new Array(route.path.length);\n\n    if (tradeType === _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TradeType.EXACT_INPUT) {\n      !amount.currency.equals(route.input) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INPUT') : 0 : void 0;\n      tokenAmounts[0] = amount.wrapped;\n\n      for (var i = 0; i < route.path.length - 1; i++) {\n        var pair = route.pairs[i];\n\n        var _pair$getOutputAmount = pair.getOutputAmount(tokenAmounts[i]),\n            outputAmount = _pair$getOutputAmount[0];\n\n        tokenAmounts[i + 1] = outputAmount;\n      }\n\n      this.inputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\n      this.outputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromFractionalAmount(route.output, tokenAmounts[tokenAmounts.length - 1].numerator, tokenAmounts[tokenAmounts.length - 1].denominator);\n    } else {\n      !amount.currency.equals(route.output) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'OUTPUT') : 0 : void 0;\n      tokenAmounts[tokenAmounts.length - 1] = amount.wrapped;\n\n      for (var _i = route.path.length - 1; _i > 0; _i--) {\n        var _pair = route.pairs[_i - 1];\n\n        var _pair$getInputAmount = _pair.getInputAmount(tokenAmounts[_i]),\n            inputAmount = _pair$getInputAmount[0];\n\n        tokenAmounts[_i - 1] = inputAmount;\n      }\n\n      this.inputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromFractionalAmount(route.input, tokenAmounts[0].numerator, tokenAmounts[0].denominator);\n      this.outputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\n    }\n\n    this.executionPrice = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n    this.priceImpact = (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.computePriceImpact)(route.midPrice, this.inputAmount, this.outputAmount);\n  }\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\n\n\n  Trade.exactIn = function exactIn(route, amountIn) {\n    return new Trade(route, amountIn, _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TradeType.EXACT_INPUT);\n  }\n  /**\r\n   * Constructs an exact out trade with the given amount out and route\r\n   * @param route route of the exact out trade\r\n   * @param amountOut the amount returned by the trade\r\n   */\n  ;\n\n  Trade.exactOut = function exactOut(route, amountOut) {\n    return new Trade(route, amountOut, _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TradeType.EXACT_OUTPUT);\n  }\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\n  ;\n\n  var _proto = Trade.prototype;\n\n  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance) {\n    !!slippageTolerance.lessThan(ZERO) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'SLIPPAGE_TOLERANCE') : 0 : void 0;\n\n    if (this.tradeType === _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TradeType.EXACT_OUTPUT) {\n      return this.outputAmount;\n    } else {\n      var slippageAdjustedAmountOut = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Fraction(ONE).add(slippageTolerance).invert().multiply(this.outputAmount.quotient).quotient;\n      return _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut);\n    }\n  }\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\n  ;\n\n  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance) {\n    !!slippageTolerance.lessThan(ZERO) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'SLIPPAGE_TOLERANCE') : 0 : void 0;\n\n    if (this.tradeType === _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TradeType.EXACT_INPUT) {\n      return this.inputAmount;\n    } else {\n      var slippageAdjustedAmountIn = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.quotient).quotient;\n      return _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn);\n    }\n  }\n  /**\r\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n   * amount to an output token, making at most `maxHops` hops.\r\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param nextAmountIn exact amount of input currency to spend\r\n   * @param currencyOut the desired currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\n  ;\n\n  Trade.bestTradeExactIn = function bestTradeExactIn(pairs, currencyAmountIn, currencyOut, _temp, // used in recursion.\n  currentPairs, nextAmountIn, bestTrades) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$maxNumResults = _ref.maxNumResults,\n        maxNumResults = _ref$maxNumResults === void 0 ? 3 : _ref$maxNumResults,\n        _ref$maxHops = _ref.maxHops,\n        maxHops = _ref$maxHops === void 0 ? 3 : _ref$maxHops;\n\n    if (currentPairs === void 0) {\n      currentPairs = [];\n    }\n\n    if (nextAmountIn === void 0) {\n      nextAmountIn = currencyAmountIn;\n    }\n\n    if (bestTrades === void 0) {\n      bestTrades = [];\n    }\n\n    !(pairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'PAIRS') : 0 : void 0;\n    !(maxHops > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'MAX_HOPS') : 0 : void 0;\n    !(currencyAmountIn === nextAmountIn || currentPairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INVALID_RECURSION') : 0 : void 0;\n    var amountIn = nextAmountIn.wrapped;\n    var tokenOut = currencyOut.wrapped;\n\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      var amountOut = void 0;\n\n      try {\n        ;\n\n        var _pair$getOutputAmount2 = pair.getOutputAmount(amountIn);\n\n        amountOut = _pair$getOutputAmount2[0];\n      } catch (error) {\n        // input too low\n        if (error.isInsufficientInputAmountError) {\n          continue;\n        }\n\n        throw error;\n      } // we have arrived at the output token, so this is the final trade of one of the paths\n\n\n      if (amountOut.currency.equals(tokenOut)) {\n        (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.sortedInsert)(bestTrades, new Trade(new Route([].concat(currentPairs, [pair]), currencyAmountIn.currency, currencyOut), currencyAmountIn, _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactIn(pairsExcludingThisPair, currencyAmountIn, currencyOut, {\n          maxNumResults: maxNumResults,\n          maxHops: maxHops - 1\n        }, [].concat(currentPairs, [pair]), amountOut, bestTrades);\n      }\n    }\n\n    return bestTrades;\n  }\n  /**\r\n   * Return the execution price after accounting for slippage tolerance\r\n   * @param slippageTolerance the allowed tolerated slippage\r\n   */\n  ;\n\n  _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {\n    return new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\n  }\n  /**\r\n   * similar to the above method but instead targets a fixed output amount\r\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n   * to an output token amount, making at most `maxHops` hops\r\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyIn the currency to spend\r\n   * @param nextAmountOut the exact amount of currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param currencyAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\n  ;\n\n  Trade.bestTradeExactOut = function bestTradeExactOut(pairs, currencyIn, currencyAmountOut, _temp2, // used in recursion.\n  currentPairs, nextAmountOut, bestTrades) {\n    var _ref2 = _temp2 === void 0 ? {} : _temp2,\n        _ref2$maxNumResults = _ref2.maxNumResults,\n        maxNumResults = _ref2$maxNumResults === void 0 ? 3 : _ref2$maxNumResults,\n        _ref2$maxHops = _ref2.maxHops,\n        maxHops = _ref2$maxHops === void 0 ? 3 : _ref2$maxHops;\n\n    if (currentPairs === void 0) {\n      currentPairs = [];\n    }\n\n    if (nextAmountOut === void 0) {\n      nextAmountOut = currencyAmountOut;\n    }\n\n    if (bestTrades === void 0) {\n      bestTrades = [];\n    }\n\n    !(pairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'PAIRS') : 0 : void 0;\n    !(maxHops > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'MAX_HOPS') : 0 : void 0;\n    !(currencyAmountOut === nextAmountOut || currentPairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INVALID_RECURSION') : 0 : void 0;\n    var amountOut = nextAmountOut.wrapped;\n    var tokenIn = currencyIn.wrapped;\n\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      var amountIn = void 0;\n\n      try {\n        ;\n\n        var _pair$getInputAmount2 = pair.getInputAmount(amountOut);\n\n        amountIn = _pair$getInputAmount2[0];\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (error.isInsufficientReservesError) {\n          continue;\n        }\n\n        throw error;\n      } // we have arrived at the input token, so this is the first trade of one of the paths\n\n\n      if (amountIn.currency.equals(tokenIn)) {\n        (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.sortedInsert)(bestTrades, new Trade(new Route([pair].concat(currentPairs), currencyIn, currencyAmountOut.currency), currencyAmountOut, _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, currencyAmountOut, {\n          maxNumResults: maxNumResults,\n          maxHops: maxHops - 1\n        }, [pair].concat(currentPairs), amountIn, bestTrades);\n      }\n    }\n\n    return bestTrades;\n  };\n\n  return Trade;\n}();\n\nfunction toHex(currencyAmount) {\n  return \"0x\" + currencyAmount.quotient.toString(16);\n}\n\nvar ZERO_HEX = '0x0';\n/**\r\n * Represents the Uniswap V2 Router, and has static methods for helping execute trades.\r\n */\n\nvar Router = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function Router() {}\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trade to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\n\n\n  Router.swapCallParameters = function swapCallParameters(trade, options) {\n    var etherIn = trade.inputAmount.currency.isNative;\n    var etherOut = trade.outputAmount.currency.isNative; // the router does not support both ether in and out\n\n    !!(etherIn && etherOut) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'ETHER_IN_OUT') : 0 : void 0;\n    !(!('ttl' in options) || options.ttl > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TTL') : 0 : void 0;\n    var to = (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.validateAndParseAddress)(options.recipient);\n    var amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n    var amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n    var path = trade.route.path.map(function (token) {\n      return token.address;\n    });\n    var deadline = 'ttl' in options ? \"0x\" + (Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16) : \"0x\" + options.deadline.toString(16);\n    var useFeeOnTransfer = Boolean(options.feeOnTransfer);\n    var methodName;\n    var args;\n    var value;\n\n    switch (trade.tradeType) {\n      case _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'; // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'; // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens' : 'swapExactTokensForTokens'; // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        }\n\n        break;\n\n      case _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TradeType.EXACT_OUTPUT:\n        !!useFeeOnTransfer ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'EXACT_OUT_FOT') : 0 : void 0;\n\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'; // (uint amountOut, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'; // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = 'swapTokensForExactTokens'; // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        }\n\n        break;\n    }\n\n    return {\n      methodName: methodName,\n      args: args,\n      value: value\n    };\n  };\n\n  return Router;\n}();\n\n\n//# sourceMappingURL=v2-sdk.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHVuaXN3YXArdjItc2RrQDMuMy4wL25vZGVfbW9kdWxlcy9AdW5pc3dhcC92Mi1zZGsvZGlzdC92Mi1zZGsuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnSztBQUN4STtBQUNlO0FBQ21CO0FBQ0M7QUFDTjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRDQUFJLGVBQWU7O0FBRXhELHdCQUF3Qiw0Q0FBSTtBQUM1Qix1QkFBdUIsNENBQUk7QUFDM0Isd0JBQXdCLDRDQUFJO0FBQzVCLHdCQUF3Qiw0Q0FBSTtBQUM1Qix5QkFBeUIsNENBQUk7QUFDN0IsZ0NBQWdDLDRDQUFJO0FBQ3BDLG9DQUFvQyxzREFBTztBQUMzQywyQ0FBMkMsc0RBQU87O0FBRWxEO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RCw4QkFBOEIsS0FBcUMsR0FBRywwREFBUywwQkFBMEIsQ0FBZ0I7QUFDekgsZ0RBQWdELEtBQXFDLEdBQUcsMERBQVMsaUJBQWlCLENBQWdCO0FBQ2xJLGFBQWEsMEVBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHdEQUFTO0FBQ3BCO0FBQ0EsMEhBQTBIOztBQUUxSDtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBIQUEwSDs7QUFFMUg7QUFDQTtBQUNBLFVBQVU7QUFDVixnSUFBZ0k7O0FBRWhJO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLHdEQUFTO0FBQ3BCLDZCQUE2QixLQUFxQyxHQUFHLDBEQUFTLDJCQUEyQixDQUFnQjs7QUFFekg7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFa047QUFDbk4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BcnRodXJMYWJzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B1bmlzd2FwK3YyLXNka0AzLjMuMC9ub2RlX21vZHVsZXMvQHVuaXN3YXAvdjItc2RrL2Rpc3QvdjItc2RrLmVzbS5qcz8xMjdhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBlcmNlbnQsIEN1cnJlbmN5QW1vdW50LCBzcXJ0LCBUb2tlbiwgUHJpY2UsIFRyYWRlVHlwZSwgRnJhY3Rpb24sIGNvbXB1dGVQcmljZUltcGFjdCwgc29ydGVkSW5zZXJ0LCB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyB9IGZyb20gJ0B1bmlzd2FwL3Nkay1jb3JlJztcbmltcG9ydCBKU0JJIGZyb20gJ2pzYmknO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIHBhY2sgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9zb2xpZGl0eSc7XG5pbXBvcnQgeyBnZXRDcmVhdGUyQWRkcmVzcyB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L2FkZHJlc3MnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyJztcblxudmFyIEZBQ1RPUllfQUREUkVTU19NQVAgPSB7XG4gIC8vIE1haW5uZXRcbiAgMTogJzB4NUM2OWJFZTcwMWVmODE0YTJCNmEzRURENEIxNjUyQ0I5Y2M1YUE2ZicsXG4gIC8vIFJvcHN0ZW5cbiAgMzogJzB4NUM2OWJFZTcwMWVmODE0YTJCNmEzRURENEIxNjUyQ0I5Y2M1YUE2ZicsXG4gIC8vIEdvZXJsaVxuICA1OiAnMHg1QzY5YkVlNzAxZWY4MTRhMkI2YTNFREQ0QjE2NTJDQjljYzVhQTZmJyxcbiAgLy8gT3B0aW1pc21cbiAgMTA6ICcweDBjM2MxYzUzMkYxZTM5RWRGMzZCRTlGZTBiRTE0MTAzMTNFMDc0QmYnLFxuICAvLyBBcmJpdHJ1bVxuICA0MjE2MTogJzB4ZjFEN0NDNjRGYjQ0NTJGMDVjNDk4MTI2MzEyZUJFMjlmMzBGYmNmOScsXG4gIC8vIEF2YWxhbmNoZVxuICA0MzExNDogJzB4OWU1QTUyZjU3YjMwMzhGMUI4RWVFNDVGMjhiM0MxOTY3ZTIyNzk5QycsXG4gIC8vIEJhc2VcbiAgODQ1MzogJzB4ODkwOWRjMTVlNDAxNzNmZjQ2OTkzNDNiNmViODEzMmM2NWUxOGVjNicsXG4gIC8vIEJOQlxuICA1NjogJzB4ODkwOURjMTVlNDAxNzNGZjQ2OTkzNDNiNmVCODEzMmM2NWUxOGVDNicsXG4gIC8vIFBvbHlnb25cbiAgMTM3OiAnMHg5ZTVBNTJmNTdiMzAzOEYxQjhFZUU0NUYyOGIzQzE5NjdlMjI3OTlDJ1xufTtcbnZhciBJTklUX0NPREVfSEFTSCA9ICcweDk2ZThhYzQyNzcxOThmZjhiNmY3ODU0NzhhYTlhMzlmNDAzY2I3NjhkZDAyY2JlZTMyNmMzZTdkYTM0ODg0NWYnO1xudmFyIE1JTklNVU1fTElRVUlESVRZID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDEwMDApOyAvLyBleHBvcnRzIGZvciBpbnRlcm5hbCBjb25zdW1wdGlvblxuXG52YXIgWkVSTyA9IC8qI19fUFVSRV9fKi9KU0JJLkJpZ0ludCgwKTtcbnZhciBPTkUgPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoMSk7XG52YXIgRklWRSA9IC8qI19fUFVSRV9fKi9KU0JJLkJpZ0ludCg1KTtcbnZhciBfOTk3ID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDk5Nyk7XG52YXIgXzEwMDAgPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoMTAwMCk7XG52YXIgQkFTSVNfUE9JTlRTID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDEwMDAwKTtcbnZhciBaRVJPX1BFUkNFTlQgPSAvKiNfX1BVUkVfXyovbmV3IFBlcmNlbnQoWkVSTyk7XG52YXIgT05FX0hVTkRSRURfUEVSQ0VOVCA9IC8qI19fUFVSRV9fKi9uZXcgUGVyY2VudChPTkUpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTtcbn1cblxuLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MTEwMjMwNlxudmFyIENBTl9TRVRfUFJPVE9UWVBFID0gKCdzZXRQcm90b3R5cGVPZicgaW4gT2JqZWN0KTtcbi8qKlxyXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcGFpciBoYXMgaW5zdWZmaWNpZW50IHJlc2VydmVzIGZvciBhIGRlc2lyZWQgb3V0cHV0IGFtb3VudC4gSS5lLiB0aGUgYW1vdW50IG9mIG91dHB1dCBjYW5ub3QgYmVcclxuICogb2J0YWluZWQgYnkgc2VuZGluZyBhbnkgYW1vdW50IG9mIGlucHV0LlxyXG4gKi9cblxudmFyIEluc3VmZmljaWVudFJlc2VydmVzRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShJbnN1ZmZpY2llbnRSZXNlcnZlc0Vycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIEluc3VmZmljaWVudFJlc2VydmVzRXJyb3IoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLmlzSW5zdWZmaWNpZW50UmVzZXJ2ZXNFcnJvciA9IHRydWU7XG4gICAgX3RoaXMubmFtZSA9IF90aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKENBTl9TRVRfUFJPVE9UWVBFKSBPYmplY3Quc2V0UHJvdG90eXBlT2YoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICh0aGlzIGluc3RhbmNlb2YgSW5zdWZmaWNpZW50UmVzZXJ2ZXNFcnJvciA/IHRoaXMuY29uc3RydWN0b3IgOiB2b2lkIDApLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEluc3VmZmljaWVudFJlc2VydmVzRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuLyoqXHJcbiAqIEluZGljYXRlcyB0aGF0IHRoZSBpbnB1dCBhbW91bnQgaXMgdG9vIHNtYWxsIHRvIHByb2R1Y2UgYW55IGFtb3VudCBvZiBvdXRwdXQuIEkuZS4gdGhlIGFtb3VudCBvZiBpbnB1dCBzZW50IGlzIGxlc3NcclxuICogdGhhbiB0aGUgcHJpY2Ugb2YgYSBzaW5nbGUgdW5pdCBvZiBvdXRwdXQgYWZ0ZXIgZmVlcy5cclxuICovXG5cbnZhciBJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IyKSB7XG4gIF9pbmhlcml0c0xvb3NlKEluc3VmZmljaWVudElucHV0QW1vdW50RXJyb3IsIF9FcnJvcjIpO1xuXG4gIGZ1bmN0aW9uIEluc3VmZmljaWVudElucHV0QW1vdW50RXJyb3IoKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF90aGlzMiA9IF9FcnJvcjIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzMi5pc0luc3VmZmljaWVudElucHV0QW1vdW50RXJyb3IgPSB0cnVlO1xuICAgIF90aGlzMi5uYW1lID0gX3RoaXMyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKENBTl9TRVRfUFJPVE9UWVBFKSBPYmplY3Quc2V0UHJvdG90eXBlT2YoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpLCAodGhpcyBpbnN0YW5jZW9mIEluc3VmZmljaWVudElucHV0QW1vdW50RXJyb3IgPyB0aGlzLmNvbnN0cnVjdG9yIDogdm9pZCAwKS5wcm90b3R5cGUpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICByZXR1cm4gSW5zdWZmaWNpZW50SW5wdXRBbW91bnRFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbnZhciBjb21wdXRlUGFpckFkZHJlc3MgPSBmdW5jdGlvbiBjb21wdXRlUGFpckFkZHJlc3MoX3JlZikge1xuICB2YXIgZmFjdG9yeUFkZHJlc3MgPSBfcmVmLmZhY3RvcnlBZGRyZXNzLFxuICAgICAgdG9rZW5BID0gX3JlZi50b2tlbkEsXG4gICAgICB0b2tlbkIgPSBfcmVmLnRva2VuQjtcblxuICB2YXIgX3JlZjIgPSB0b2tlbkEuc29ydHNCZWZvcmUodG9rZW5CKSA/IFt0b2tlbkEsIHRva2VuQl0gOiBbdG9rZW5CLCB0b2tlbkFdLFxuICAgICAgdG9rZW4wID0gX3JlZjJbMF0sXG4gICAgICB0b2tlbjEgPSBfcmVmMlsxXTsgLy8gZG9lcyBzYWZldHkgY2hlY2tzXG5cblxuICByZXR1cm4gZ2V0Q3JlYXRlMkFkZHJlc3MoZmFjdG9yeUFkZHJlc3MsIGtlY2NhazI1NihbJ2J5dGVzJ10sIFtwYWNrKFsnYWRkcmVzcycsICdhZGRyZXNzJ10sIFt0b2tlbjAuYWRkcmVzcywgdG9rZW4xLmFkZHJlc3NdKV0pLCBJTklUX0NPREVfSEFTSCk7XG59O1xudmFyIFBhaXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYWlyKGN1cnJlbmN5QW1vdW50QSwgdG9rZW5BbW91bnRCKSB7XG4gICAgdmFyIHRva2VuQW1vdW50cyA9IGN1cnJlbmN5QW1vdW50QS5jdXJyZW5jeS5zb3J0c0JlZm9yZSh0b2tlbkFtb3VudEIuY3VycmVuY3kpIC8vIGRvZXMgc2FmZXR5IGNoZWNrc1xuICAgID8gW2N1cnJlbmN5QW1vdW50QSwgdG9rZW5BbW91bnRCXSA6IFt0b2tlbkFtb3VudEIsIGN1cnJlbmN5QW1vdW50QV07XG4gICAgdGhpcy5saXF1aWRpdHlUb2tlbiA9IG5ldyBUb2tlbih0b2tlbkFtb3VudHNbMF0uY3VycmVuY3kuY2hhaW5JZCwgUGFpci5nZXRBZGRyZXNzKHRva2VuQW1vdW50c1swXS5jdXJyZW5jeSwgdG9rZW5BbW91bnRzWzFdLmN1cnJlbmN5KSwgMTgsICdVTkktVjInLCAnVW5pc3dhcCBWMicpO1xuICAgIHRoaXMudG9rZW5BbW91bnRzID0gdG9rZW5BbW91bnRzO1xuICB9XG5cbiAgUGFpci5nZXRBZGRyZXNzID0gZnVuY3Rpb24gZ2V0QWRkcmVzcyh0b2tlbkEsIHRva2VuQikge1xuICAgIHJldHVybiBjb21wdXRlUGFpckFkZHJlc3Moe1xuICAgICAgZmFjdG9yeUFkZHJlc3M6IEZBQ1RPUllfQUREUkVTU19NQVBbdG9rZW5BLmNoYWluSWRdLFxuICAgICAgdG9rZW5BOiB0b2tlbkEsXG4gICAgICB0b2tlbkI6IHRva2VuQlxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9rZW4gaXMgZWl0aGVyIHRva2VuMCBvciB0b2tlbjFcclxuICAgKiBAcGFyYW0gdG9rZW4gdG8gY2hlY2tcclxuICAgKi9cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBQYWlyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW52b2x2ZXNUb2tlbiA9IGZ1bmN0aW9uIGludm9sdmVzVG9rZW4odG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW4uZXF1YWxzKHRoaXMudG9rZW4wKSB8fCB0b2tlbi5lcXVhbHModGhpcy50b2tlbjEpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWlkIHByaWNlIG9mIHRoZSBwYWlyIGluIHRlcm1zIG9mIHRva2VuMCwgaS5lLiB0aGUgcmF0aW8gb2YgcmVzZXJ2ZTEgdG8gcmVzZXJ2ZTBcclxuICAgKi9cbiAgO1xuXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgcHJpY2Ugb2YgdGhlIGdpdmVuIHRva2VuIGluIHRlcm1zIG9mIHRoZSBvdGhlciB0b2tlbiBpbiB0aGUgcGFpci5cclxuICAgKiBAcGFyYW0gdG9rZW4gdG9rZW4gdG8gcmV0dXJuIHByaWNlIG9mXHJcbiAgICovXG4gIF9wcm90by5wcmljZU9mID0gZnVuY3Rpb24gcHJpY2VPZih0b2tlbikge1xuICAgICF0aGlzLmludm9sdmVzVG9rZW4odG9rZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVE9LRU4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHRva2VuLmVxdWFscyh0aGlzLnRva2VuMCkgPyB0aGlzLnRva2VuMFByaWNlIDogdGhpcy50b2tlbjFQcmljZTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjaGFpbiBJRCBvZiB0aGUgdG9rZW5zIGluIHRoZSBwYWlyLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlc2VydmVPZiA9IGZ1bmN0aW9uIHJlc2VydmVPZih0b2tlbikge1xuICAgICF0aGlzLmludm9sdmVzVG9rZW4odG9rZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVE9LRU4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHRva2VuLmVxdWFscyh0aGlzLnRva2VuMCkgPyB0aGlzLnJlc2VydmUwIDogdGhpcy5yZXNlcnZlMTtcbiAgfVxuICAvKipcclxuICAgKiBnZXRBbW91bnRPdXQgaXMgdGhlIGxpbmVhciBhbGdlYnJhIG9mIHJlc2VydmUgcmF0aW8gYWdhaW5zdCBhbW91bnRJbjphbW91bnRPdXQuXHJcbiAgICogaHR0cHM6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTAxNjI5L3doYXQtaXMtbWF0aC1mb3ItdW5pc3dhcC1jYWxjdWxhdGVzLXRoZS1hbW91bnRvdXQtYW5kLWFtb3VudGluLXdoeS05OTctYW5kLTEwMDBcclxuICAgKiBoYXMgdGhlIG1hdGggZGVkdWN0aW9uIGZvciB0aGUgcmVzZXJ2ZSBjYWxjdWxhdGlvbiB3aXRob3V0IGZlZS1vbi10cmFuc2ZlciBmZWVzLlxyXG4gICAqXHJcbiAgICogV2l0aCBmZWUtb24tdHJhbnNmZXIgdGF4LCBpbnR1aXRpdmVseSBpdCdzIGp1c3Q6XHJcbiAgICogaW5wdXRBbW91bnRXaXRoRmVlQW5kVGF4ID0gMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSAqIGFtb3VudEluXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgID0gKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkgKiBhbW91bnRJbldpdGhGZWVcclxuICAgKiB3aGVyZSBhbW91bnRJbldpdGhGZWUgaXMgdGhlIGFtb3VudEluIGFmdGVyIHRha2luZyBvdXQgdGhlIExQIGZlZXNcclxuICAgKiBvdXRwdXRBbW91bnRXaXRoVGF4ID0gYW1vdW50T3V0ICogKDEgLSBhbW91bnRPdXQuYnV5RmVlc0JpcHMgLyAxMDAwMClcclxuICAgKlxyXG4gICAqIEJ1dCB3ZSBhcmUgaWxsdXN0cmF0aW5nIHRoZSBtYXRoIGRlZHVjdGlvbiBiZWxvdyB0byBlbnN1cmUgdGhhdCdzIHRoZSBjYXNlLlxyXG4gICAqXHJcbiAgICogYmVmb3JlIHN3YXAgQSAqIEIgPSBLIHdoZXJlIEEgPSByZXNlcnZlSW4gQiA9IHJlc2VydmVPdXRcclxuICAgKlxyXG4gICAqIGFmdGVyIHN3YXAgQScgKiBCJyA9IEsgd2hlcmUgb25seSBrIGlzIGEgY29uc3RhbnQgdmFsdWVcclxuICAgKlxyXG4gICAqIGdldEFtb3VudE91dFxyXG4gICAqXHJcbiAgICogQScgPSBBICsgMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSAqIGFtb3VudEluICMgaGVyZSAwLjMlIGlzIGRlZHVjdGVkXHJcbiAgICogQicgPSBCIC0gYW1vdW50T3V0ICogKDEgLSBhbW91bnRPdXQuYnV5RmVlc0JpcHMgLyAxMDAwMClcclxuICAgKiBhbW91bnRPdXQgPSAoQiAtIEInKSAvICgxIC0gYW1vdW50T3V0LmJ1eUZlZXNCaXBzIC8gMTAwMDApICMgd2hlcmUgQScgKiBCJyBzdGlsbCBpcyBrXHJcbiAgICogICAgICAgICAgID0gKEIgLSBLLyhBICsgMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSAqIGFtb3VudEluKSlcclxuICAgKiAgICAgICAgICAgICAvXHJcbiAgICogICAgICAgICAgICAgKDEgLSBhbW91bnRPdXQuYnV5RmVlc0JpcHMgLyAxMDAwMClcclxuICAgKiAgICAgICAgICAgPSAoQiAtIEFCLyhBICsgMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSAqIGFtb3VudEluKSlcclxuICAgKiAgICAgICAgICAgICAvXHJcbiAgICogICAgICAgICAgICAgKDEgLSBhbW91bnRPdXQuYnV5RmVlc0JpcHMgLyAxMDAwMClcclxuICAgKiAgICAgICAgICAgPSAoKEJBICsgQiAqIDAuOTk3ICogKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkgKiBhbW91bnRJbiAtIEFCKS8oQSArIDAuOTk3ICogKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkgKiBhbW91bnRJbikpXHJcbiAgICogICAgICAgICAgICAgL1xyXG4gICAqICAgICAgICAgICAgICgxIC0gYW1vdW50T3V0LmJ1eUZlZXNCaXBzIC8gMTAwMDApXHJcbiAgICogICAgICAgICAgID0gKEIgKiAwLjk5NyAqICgxIC0gYW1vdW50SW4uc2VsbEZlZXNCaXBzIC8gMTAwMDApICogYW1vdW50SW4gLyAoQSArIDAuOTk3ICogKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkgKiBhbW91bnRJbilcclxuICAgKiAgICAgICAgICAgICAvXHJcbiAgICogICAgICAgICAgICAgKDEgLSBhbW91bnRPdXQuYnV5RmVlc0JpcHMgLyAxMDAwMClcclxuICAgKiBhbW91bnRPdXQgKiAoMSAtIGFtb3VudE91dC5idXlGZWVzQmlwcyAvIDEwMDAwKSA9IChCICogMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSAqIGFtb3VudEluXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgL1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChBICsgMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSAqIGFtb3VudEluKVxyXG4gICAqXHJcbiAgICogb3V0cHV0QW1vdW50V2l0aFRheCA9IChCICogMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSAqIGFtb3VudEluXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC9cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgKEEgKyAwLjk5NyAqICgxIC0gYW1vdW50SW4uc2VsbEZlZXNCaXBzIC8gMTAwMDApICogYW1vdW50SW4pXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgID0gKEIgKiAwLjk5NyAqICgxIC0gYW1vdW50SW4uc2VsbEZlZXNCaXBzIC8gMTAwMDApICogYW1vdW50SW4gKiAxMDAwXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC9cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgKChBICsgMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSAqIGFtb3VudEluKSAqIDEwMDApXHJcbiAgICogICAgICAgICAgICAgICAgICAgICA9IChCICogKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkgOTk3ICogKiBhbW91bnRJblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAvXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICgxMDAwICogQSArICgxIC0gYW1vdW50SW4uc2VsbEZlZXNCaXBzIC8gMTAwMDApICogOTk3ICogYW1vdW50SW4pXHJcbiAgICogICAgICAgICAgICAgICAgICAgICA9IChCICogKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkgKiBpbnB1dEFtb3VudFdpdGhGZWUpXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC9cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgKDEwMDAgKiBBICsgKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkgKiBpbnB1dEFtb3VudFdpdGhGZWUpXHJcbiAgICogICAgICAgICAgICAgICAgICAgICA9IChCICogaW5wdXRBbW91bnRXaXRoRmVlQW5kVGF4KVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAvXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICgxMDAwICogQSArIGlucHV0QW1vdW50V2l0aEZlZUFuZFRheClcclxuICAgKlxyXG4gICAqIGlucHV0QW1vdW50V2l0aEZlZUFuZFRheCA9ICgxIC0gYW1vdW50SW4uc2VsbEZlZXNCaXBzIC8gMTAwMDApICogaW5wdXRBbW91bnRXaXRoRmVlXHJcbiAgICogb3V0cHV0QW1vdW50V2l0aFRheCA9IGFtb3VudE91dCAqICgxIC0gYW1vdW50T3V0LmJ1eUZlZXNCaXBzIC8gMTAwMDApXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW5wdXRBbW91bnRcclxuICAgKiBAcGFyYW0gY2FsY3VsYXRlRm90RmVlc1xyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldE91dHB1dEFtb3VudCA9IGZ1bmN0aW9uIGdldE91dHB1dEFtb3VudChpbnB1dEFtb3VudCwgY2FsY3VsYXRlRm90RmVlcykge1xuICAgIGlmIChjYWxjdWxhdGVGb3RGZWVzID09PSB2b2lkIDApIHtcbiAgICAgIGNhbGN1bGF0ZUZvdEZlZXMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAhdGhpcy5pbnZvbHZlc1Rva2VuKGlucHV0QW1vdW50LmN1cnJlbmN5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1RPS0VOJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKEpTQkkuZXF1YWwodGhpcy5yZXNlcnZlMC5xdW90aWVudCwgWkVSTykgfHwgSlNCSS5lcXVhbCh0aGlzLnJlc2VydmUxLnF1b3RpZW50LCBaRVJPKSkge1xuICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudFJlc2VydmVzRXJyb3IoKTtcbiAgICB9XG5cbiAgICB2YXIgaW5wdXRSZXNlcnZlID0gdGhpcy5yZXNlcnZlT2YoaW5wdXRBbW91bnQuY3VycmVuY3kpO1xuICAgIHZhciBvdXRwdXRSZXNlcnZlID0gdGhpcy5yZXNlcnZlT2YoaW5wdXRBbW91bnQuY3VycmVuY3kuZXF1YWxzKHRoaXMudG9rZW4wKSA/IHRoaXMudG9rZW4xIDogdGhpcy50b2tlbjApO1xuICAgIHZhciBwZXJjZW50QWZ0ZXJTZWxsRmVlcyA9IGNhbGN1bGF0ZUZvdEZlZXMgPyB0aGlzLmRlcml2ZVBlcmNlbnRBZnRlclNlbGxGZWVzKGlucHV0QW1vdW50KSA6IFpFUk9fUEVSQ0VOVDtcbiAgICB2YXIgaW5wdXRBbW91bnRBZnRlclRheCA9IHBlcmNlbnRBZnRlclNlbGxGZWVzLmdyZWF0ZXJUaGFuKFpFUk9fUEVSQ0VOVCkgPyBDdXJyZW5jeUFtb3VudC5mcm9tUmF3QW1vdW50KGlucHV0QW1vdW50LmN1cnJlbmN5LCBwZXJjZW50QWZ0ZXJTZWxsRmVlcy5tdWx0aXBseShpbnB1dEFtb3VudCkucXVvdGllbnQgLy8gZnJhY3Rpb24ucXVvdGllbnQgd2lsbCByb3VuZCBkb3duIGJ5IGl0c2VsZiwgd2hpY2ggaXMgZGVzaXJlZFxuICAgICkgOiBpbnB1dEFtb3VudDtcbiAgICB2YXIgaW5wdXRBbW91bnRXaXRoRmVlQW5kQWZ0ZXJUYXggPSBKU0JJLm11bHRpcGx5KGlucHV0QW1vdW50QWZ0ZXJUYXgucXVvdGllbnQsIF85OTcpO1xuICAgIHZhciBudW1lcmF0b3IgPSBKU0JJLm11bHRpcGx5KGlucHV0QW1vdW50V2l0aEZlZUFuZEFmdGVyVGF4LCBvdXRwdXRSZXNlcnZlLnF1b3RpZW50KTtcbiAgICB2YXIgZGVub21pbmF0b3IgPSBKU0JJLmFkZChKU0JJLm11bHRpcGx5KGlucHV0UmVzZXJ2ZS5xdW90aWVudCwgXzEwMDApLCBpbnB1dEFtb3VudFdpdGhGZWVBbmRBZnRlclRheCk7XG4gICAgdmFyIG91dHB1dEFtb3VudCA9IEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQoaW5wdXRBbW91bnQuY3VycmVuY3kuZXF1YWxzKHRoaXMudG9rZW4wKSA/IHRoaXMudG9rZW4xIDogdGhpcy50b2tlbjAsIEpTQkkuZGl2aWRlKG51bWVyYXRvciwgZGVub21pbmF0b3IpIC8vIEpTQkkuZGl2aWRlIHdpbGwgcm91bmQgZG93biBieSBpdHNlbGYsIHdoaWNoIGlzIGRlc2lyZWRcbiAgICApO1xuXG4gICAgaWYgKEpTQkkuZXF1YWwob3V0cHV0QW1vdW50LnF1b3RpZW50LCBaRVJPKSkge1xuICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudElucHV0QW1vdW50RXJyb3IoKTtcbiAgICB9XG5cbiAgICB2YXIgcGVyY2VudEFmdGVyQnV5RmVlcyA9IGNhbGN1bGF0ZUZvdEZlZXMgPyB0aGlzLmRlcml2ZVBlcmNlbnRBZnRlckJ1eUZlZXMob3V0cHV0QW1vdW50KSA6IFpFUk9fUEVSQ0VOVDtcbiAgICB2YXIgb3V0cHV0QW1vdW50QWZ0ZXJUYXggPSBwZXJjZW50QWZ0ZXJCdXlGZWVzLmdyZWF0ZXJUaGFuKFpFUk9fUEVSQ0VOVCkgPyBDdXJyZW5jeUFtb3VudC5mcm9tUmF3QW1vdW50KG91dHB1dEFtb3VudC5jdXJyZW5jeSwgb3V0cHV0QW1vdW50Lm11bHRpcGx5KHBlcmNlbnRBZnRlckJ1eUZlZXMpLnF1b3RpZW50IC8vIGZyYWN0aW9uLnF1b3RpZW50IHdpbGwgcm91bmQgZG93biBieSBpdHNlbGYsIHdoaWNoIGlzIGRlc2lyZWRcbiAgICApIDogb3V0cHV0QW1vdW50O1xuXG4gICAgaWYgKEpTQkkuZXF1YWwob3V0cHV0QW1vdW50QWZ0ZXJUYXgucXVvdGllbnQsIFpFUk8pKSB7XG4gICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50SW5wdXRBbW91bnRFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiBbb3V0cHV0QW1vdW50QWZ0ZXJUYXgsIG5ldyBQYWlyKGlucHV0UmVzZXJ2ZS5hZGQoaW5wdXRBbW91bnRBZnRlclRheCksIG91dHB1dFJlc2VydmUuc3VidHJhY3Qob3V0cHV0QW1vdW50QWZ0ZXJUYXgpKV07XG4gIH1cbiAgLyoqXHJcbiAgICogZ2V0QW1vdW50SW4gaXMgdGhlIGxpbmVhciBhbGdlYnJhIG9mIHJlc2VydmUgcmF0aW8gYWdhaW5zdCBhbW91bnRJbjphbW91bnRPdXQuXHJcbiAgICogaHR0cHM6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTAxNjI5L3doYXQtaXMtbWF0aC1mb3ItdW5pc3dhcC1jYWxjdWxhdGVzLXRoZS1hbW91bnRvdXQtYW5kLWFtb3VudGluLXdoeS05OTctYW5kLTEwMDBcclxuICAgKiBoYXMgdGhlIG1hdGggZGVkdWN0aW9uIGZvciB0aGUgcmVzZXJ2ZSBjYWxjdWxhdGlvbiB3aXRob3V0IGZlZS1vbi10cmFuc2ZlciBmZWVzLlxyXG4gICAqXHJcbiAgICogV2l0aCBmZWUtb24tdHJhbnNmZXIgZmVlcywgaW50dWl0aXZlbHkgaXQncyBqdXN0OlxyXG4gICAqIG91dHB1dEFtb3VudFdpdGhUYXggPSBhbW91bnRPdXQgLyAoMSAtIGFtb3VudE91dC5idXlGZWVzQmlwcyAvIDEwMDAwKVxyXG4gICAqIGlucHV0QW1vdW50V2l0aFRheCA9IGFtb3VudEluIC8gKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkgLyAwLjk5N1xyXG4gICAqXHJcbiAgICogQnV0IHdlIGFyZSBpbGx1c3RyYXRpbmcgdGhlIG1hdGggZGVkdWN0aW9uIGJlbG93IHRvIGVuc3VyZSB0aGF0J3MgdGhlIGNhc2UuXHJcbiAgICpcclxuICAgKiBiZWZvcmUgc3dhcCBBICogQiA9IEsgd2hlcmUgQSA9IHJlc2VydmVJbiBCID0gcmVzZXJ2ZU91dFxyXG4gICAqXHJcbiAgICogYWZ0ZXIgc3dhcCBBJyAqIEInID0gSyB3aGVyZSBvbmx5IGsgaXMgYSBjb25zdGFudCB2YWx1ZVxyXG4gICAqXHJcbiAgICogZ2V0QW1vdW50SW5cclxuICAgKlxyXG4gICAqIEInID0gQiAtIGFtb3VudE91dCAqICgxIC0gYW1vdW50T3V0LmJ1eUZlZXNCaXBzIC8gMTAwMDApXHJcbiAgICogQScgPSBBICsgMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSAqIGFtb3VudEluICMgaGVyZSAwLjMlIGlzIGRlZHVjdGVkXHJcbiAgICogYW1vdW50SW4gPSAoQScgLSBBKSAvICgwLjk5NyAqICgxIC0gYW1vdW50SW4uc2VsbEZlZXNCaXBzIC8gMTAwMDApKVxyXG4gICAqICAgICAgICAgID0gKEsgLyAoQiAtIGFtb3VudE91dCAvICgxIC0gYW1vdW50T3V0LmJ1eUZlZXNCaXBzIC8gMTAwMDApKSAtIEEpXHJcbiAgICogICAgICAgICAgICAvXHJcbiAgICogICAgICAgICAgICAoMC45OTcgKiAoMSAtIGFtb3VudEluLnNlbGxGZWVzQmlwcyAvIDEwMDAwKSlcclxuICAgKiAgICAgICAgICA9IChBQiAvIChCIC0gYW1vdW50T3V0IC8gKDEgLSBhbW91bnRPdXQuYnV5RmVlc0JpcHMgLyAxMDAwMCkpIC0gQSlcclxuICAgKiAgICAgICAgICAgIC9cclxuICAgKiAgICAgICAgICAgICgwLjk5NyAqICgxIC0gYW1vdW50SW4uc2VsbEZlZXNCaXBzIC8gMTAwMDApKVxyXG4gICAqICAgICAgICAgID0gKChBQiAtIEFCICsgQSAqIGFtb3VudE91dCAvICgxIC0gYW1vdW50T3V0LmJ1eUZlZXNCaXBzIC8gMTAwMDApKSAvIChCIC0gYW1vdW50T3V0IC8gKDEgLSBhbW91bnRPdXQuYnV5RmVlc0JpcHMgLyAxMDAwMCkpKVxyXG4gICAqICAgICAgICAgICAgL1xyXG4gICAqICAgICAgICAgICAgKDAuOTk3ICogKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkpXHJcbiAgICogICAgICAgICAgPSAoKEEgKiBhbW91bnRPdXQgLyAoMSAtIGFtb3VudE91dC5idXlGZWVzQmlwcyAvIDEwMDAwKSkgLyAoQiAtIGFtb3VudE91dCAvICgxIC0gYW1vdW50T3V0LmJ1eUZlZXNCaXBzIC8gMTAwMDApKSlcclxuICAgKiAgICAgICAgICAgIC9cclxuICAgKiAgICAgICAgICAgICgwLjk5NyAqICgxIC0gYW1vdW50SW4uc2VsbEZlZXNCaXBzIC8gMTAwMDApKVxyXG4gICAqICAgICAgICAgID0gKChBICogMTAwMCAqIGFtb3VudE91dCAvICgxIC0gYW1vdW50T3V0LmJ1eUZlZXNCaXBzIC8gMTAwMDApKSAvIChCIC0gYW1vdW50T3V0IC8gKDEgLSBhbW91bnRPdXQuYnV5RmVlc0JpcHMgLyAxMDAwMCkpKVxyXG4gICAqICAgICAgICAgICAgL1xyXG4gICAqICAgICAgICAgICAgKDk5NyAqICgxIC0gYW1vdW50SW4uc2VsbEZlZXNCaXBzIC8gMTAwMDApKVxyXG4gICAqXHJcbiAgICogb3V0cHV0QW1vdW50V2l0aFRheCA9IGFtb3VudE91dCAvICgxIC0gYW1vdW50T3V0LmJ1eUZlZXNCaXBzIC8gMTAwMDApXHJcbiAgICogaW5wdXRBbW91bnRXaXRoVGF4ID0gYW1vdW50SW4gLyAoOTk3ICogKDEgLSBhbW91bnRJbi5zZWxsRmVlc0JpcHMgLyAxMDAwMCkpXHJcbiAgICogICAgICAgICAgICAgICAgICAgID0gKEEgKiBvdXRwdXRBbW91bnRXaXRoVGF4ICogMTAwMCkgLyAoKEIgLSBvdXRwdXRBbW91bnRXaXRoVGF4KSAqIDk5NylcclxuICAgKlxyXG4gICAqIEBwYXJhbSBvdXRwdXRBbW91bnRcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRJbnB1dEFtb3VudCA9IGZ1bmN0aW9uIGdldElucHV0QW1vdW50KG91dHB1dEFtb3VudCwgY2FsY3VsYXRlRm90RmVlcykge1xuICAgIGlmIChjYWxjdWxhdGVGb3RGZWVzID09PSB2b2lkIDApIHtcbiAgICAgIGNhbGN1bGF0ZUZvdEZlZXMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAhdGhpcy5pbnZvbHZlc1Rva2VuKG91dHB1dEFtb3VudC5jdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT0tFTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgcGVyY2VudEFmdGVyQnV5RmVlcyA9IGNhbGN1bGF0ZUZvdEZlZXMgPyB0aGlzLmRlcml2ZVBlcmNlbnRBZnRlckJ1eUZlZXMob3V0cHV0QW1vdW50KSA6IFpFUk9fUEVSQ0VOVDtcbiAgICB2YXIgb3V0cHV0QW1vdW50QmVmb3JlVGF4ID0gcGVyY2VudEFmdGVyQnV5RmVlcy5ncmVhdGVyVGhhbihaRVJPX1BFUkNFTlQpID8gQ3VycmVuY3lBbW91bnQuZnJvbVJhd0Ftb3VudChvdXRwdXRBbW91bnQuY3VycmVuY3ksIEpTQkkuYWRkKG91dHB1dEFtb3VudC5kaXZpZGUocGVyY2VudEFmdGVyQnV5RmVlcykucXVvdGllbnQsIE9ORSkgLy8gYWRkIDEgZm9yIHJvdW5kaW5nIHVwXG4gICAgKSA6IG91dHB1dEFtb3VudDtcblxuICAgIGlmIChKU0JJLmVxdWFsKHRoaXMucmVzZXJ2ZTAucXVvdGllbnQsIFpFUk8pIHx8IEpTQkkuZXF1YWwodGhpcy5yZXNlcnZlMS5xdW90aWVudCwgWkVSTykgfHwgSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwob3V0cHV0QW1vdW50LnF1b3RpZW50LCB0aGlzLnJlc2VydmVPZihvdXRwdXRBbW91bnQuY3VycmVuY3kpLnF1b3RpZW50KSB8fCBKU0JJLmdyZWF0ZXJUaGFuT3JFcXVhbChvdXRwdXRBbW91bnRCZWZvcmVUYXgucXVvdGllbnQsIHRoaXMucmVzZXJ2ZU9mKG91dHB1dEFtb3VudC5jdXJyZW5jeSkucXVvdGllbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50UmVzZXJ2ZXNFcnJvcigpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXRSZXNlcnZlID0gdGhpcy5yZXNlcnZlT2Yob3V0cHV0QW1vdW50LmN1cnJlbmN5KTtcbiAgICB2YXIgaW5wdXRSZXNlcnZlID0gdGhpcy5yZXNlcnZlT2Yob3V0cHV0QW1vdW50LmN1cnJlbmN5LmVxdWFscyh0aGlzLnRva2VuMCkgPyB0aGlzLnRva2VuMSA6IHRoaXMudG9rZW4wKTtcbiAgICB2YXIgbnVtZXJhdG9yID0gSlNCSS5tdWx0aXBseShKU0JJLm11bHRpcGx5KGlucHV0UmVzZXJ2ZS5xdW90aWVudCwgb3V0cHV0QW1vdW50QmVmb3JlVGF4LnF1b3RpZW50KSwgXzEwMDApO1xuICAgIHZhciBkZW5vbWluYXRvciA9IEpTQkkubXVsdGlwbHkoSlNCSS5zdWJ0cmFjdChvdXRwdXRSZXNlcnZlLnF1b3RpZW50LCBvdXRwdXRBbW91bnRCZWZvcmVUYXgucXVvdGllbnQpLCBfOTk3KTtcbiAgICB2YXIgaW5wdXRBbW91bnQgPSBDdXJyZW5jeUFtb3VudC5mcm9tUmF3QW1vdW50KG91dHB1dEFtb3VudC5jdXJyZW5jeS5lcXVhbHModGhpcy50b2tlbjApID8gdGhpcy50b2tlbjEgOiB0aGlzLnRva2VuMCwgSlNCSS5hZGQoSlNCSS5kaXZpZGUobnVtZXJhdG9yLCBkZW5vbWluYXRvciksIE9ORSkgLy8gYWRkIDEgaGVyZSBpcyBwYXJ0IG9mIHRoZSBmb3JtdWxhLCBubyByb3VuZGluZyBuZWVkZWQgaGVyZSwgc2luY2UgdGhlcmUgd2lsbCBub3QgYmUgZGVjaW1hbCBhdCB0aGlzIHBvaW50XG4gICAgKTtcbiAgICB2YXIgcGVyY2VudEFmdGVyU2VsbEZlZXMgPSBjYWxjdWxhdGVGb3RGZWVzID8gdGhpcy5kZXJpdmVQZXJjZW50QWZ0ZXJTZWxsRmVlcyhpbnB1dEFtb3VudCkgOiBaRVJPX1BFUkNFTlQ7XG4gICAgdmFyIGlucHV0QW1vdW50QmVmb3JlVGF4ID0gcGVyY2VudEFmdGVyU2VsbEZlZXMuZ3JlYXRlclRoYW4oWkVST19QRVJDRU5UKSA/IEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQoaW5wdXRBbW91bnQuY3VycmVuY3ksIEpTQkkuYWRkKGlucHV0QW1vdW50LmRpdmlkZShwZXJjZW50QWZ0ZXJTZWxsRmVlcykucXVvdGllbnQsIE9ORSkgLy8gYWRkIDEgZm9yIHJvdW5kaW5nIHVwXG4gICAgKSA6IGlucHV0QW1vdW50O1xuICAgIHJldHVybiBbaW5wdXRBbW91bnRCZWZvcmVUYXgsIG5ldyBQYWlyKGlucHV0UmVzZXJ2ZS5hZGQoaW5wdXRBbW91bnQpLCBvdXRwdXRSZXNlcnZlLnN1YnRyYWN0KG91dHB1dEFtb3VudCkpXTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TGlxdWlkaXR5TWludGVkID0gZnVuY3Rpb24gZ2V0TGlxdWlkaXR5TWludGVkKHRvdGFsU3VwcGx5LCB0b2tlbkFtb3VudEEsIHRva2VuQW1vdW50Qikge1xuICAgICF0b3RhbFN1cHBseS5jdXJyZW5jeS5lcXVhbHModGhpcy5saXF1aWRpdHlUb2tlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdMSVFVSURJVFknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIHRva2VuQW1vdW50cyA9IHRva2VuQW1vdW50QS5jdXJyZW5jeS5zb3J0c0JlZm9yZSh0b2tlbkFtb3VudEIuY3VycmVuY3kpIC8vIGRvZXMgc2FmZXR5IGNoZWNrc1xuICAgID8gW3Rva2VuQW1vdW50QSwgdG9rZW5BbW91bnRCXSA6IFt0b2tlbkFtb3VudEIsIHRva2VuQW1vdW50QV07XG4gICAgISh0b2tlbkFtb3VudHNbMF0uY3VycmVuY3kuZXF1YWxzKHRoaXMudG9rZW4wKSAmJiB0b2tlbkFtb3VudHNbMV0uY3VycmVuY3kuZXF1YWxzKHRoaXMudG9rZW4xKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT0tFTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgbGlxdWlkaXR5O1xuXG4gICAgaWYgKEpTQkkuZXF1YWwodG90YWxTdXBwbHkucXVvdGllbnQsIFpFUk8pKSB7XG4gICAgICBsaXF1aWRpdHkgPSBKU0JJLnN1YnRyYWN0KHNxcnQoSlNCSS5tdWx0aXBseSh0b2tlbkFtb3VudHNbMF0ucXVvdGllbnQsIHRva2VuQW1vdW50c1sxXS5xdW90aWVudCkpLCBNSU5JTVVNX0xJUVVJRElUWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbW91bnQwID0gSlNCSS5kaXZpZGUoSlNCSS5tdWx0aXBseSh0b2tlbkFtb3VudHNbMF0ucXVvdGllbnQsIHRvdGFsU3VwcGx5LnF1b3RpZW50KSwgdGhpcy5yZXNlcnZlMC5xdW90aWVudCk7XG4gICAgICB2YXIgYW1vdW50MSA9IEpTQkkuZGl2aWRlKEpTQkkubXVsdGlwbHkodG9rZW5BbW91bnRzWzFdLnF1b3RpZW50LCB0b3RhbFN1cHBseS5xdW90aWVudCksIHRoaXMucmVzZXJ2ZTEucXVvdGllbnQpO1xuICAgICAgbGlxdWlkaXR5ID0gSlNCSS5sZXNzVGhhbk9yRXF1YWwoYW1vdW50MCwgYW1vdW50MSkgPyBhbW91bnQwIDogYW1vdW50MTtcbiAgICB9XG5cbiAgICBpZiAoIUpTQkkuZ3JlYXRlclRoYW4obGlxdWlkaXR5LCBaRVJPKSkge1xuICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudElucHV0QW1vdW50RXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ3VycmVuY3lBbW91bnQuZnJvbVJhd0Ftb3VudCh0aGlzLmxpcXVpZGl0eVRva2VuLCBsaXF1aWRpdHkpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMaXF1aWRpdHlWYWx1ZSA9IGZ1bmN0aW9uIGdldExpcXVpZGl0eVZhbHVlKHRva2VuLCB0b3RhbFN1cHBseSwgbGlxdWlkaXR5LCBmZWVPbiwga0xhc3QpIHtcbiAgICBpZiAoZmVlT24gPT09IHZvaWQgMCkge1xuICAgICAgZmVlT24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAhdGhpcy5pbnZvbHZlc1Rva2VuKHRva2VuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1RPS0VOJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICF0b3RhbFN1cHBseS5jdXJyZW5jeS5lcXVhbHModGhpcy5saXF1aWRpdHlUb2tlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT1RBTF9TVVBQTFknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIWxpcXVpZGl0eS5jdXJyZW5jeS5lcXVhbHModGhpcy5saXF1aWRpdHlUb2tlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdMSVFVSURJVFknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIUpTQkkubGVzc1RoYW5PckVxdWFsKGxpcXVpZGl0eS5xdW90aWVudCwgdG90YWxTdXBwbHkucXVvdGllbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTElRVUlESVRZJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciB0b3RhbFN1cHBseUFkanVzdGVkO1xuXG4gICAgaWYgKCFmZWVPbikge1xuICAgICAgdG90YWxTdXBwbHlBZGp1c3RlZCA9IHRvdGFsU3VwcGx5O1xuICAgIH0gZWxzZSB7XG4gICAgICAhISFrTGFzdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0tfTEFTVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHZhciBrTGFzdFBhcnNlZCA9IEpTQkkuQmlnSW50KGtMYXN0KTtcblxuICAgICAgaWYgKCFKU0JJLmVxdWFsKGtMYXN0UGFyc2VkLCBaRVJPKSkge1xuICAgICAgICB2YXIgcm9vdEsgPSBzcXJ0KEpTQkkubXVsdGlwbHkodGhpcy5yZXNlcnZlMC5xdW90aWVudCwgdGhpcy5yZXNlcnZlMS5xdW90aWVudCkpO1xuICAgICAgICB2YXIgcm9vdEtMYXN0ID0gc3FydChrTGFzdFBhcnNlZCk7XG5cbiAgICAgICAgaWYgKEpTQkkuZ3JlYXRlclRoYW4ocm9vdEssIHJvb3RLTGFzdCkpIHtcbiAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gSlNCSS5tdWx0aXBseSh0b3RhbFN1cHBseS5xdW90aWVudCwgSlNCSS5zdWJ0cmFjdChyb290Sywgcm9vdEtMYXN0KSk7XG4gICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gSlNCSS5hZGQoSlNCSS5tdWx0aXBseShyb290SywgRklWRSksIHJvb3RLTGFzdCk7XG4gICAgICAgICAgdmFyIGZlZUxpcXVpZGl0eSA9IEpTQkkuZGl2aWRlKG51bWVyYXRvciwgZGVub21pbmF0b3IpO1xuICAgICAgICAgIHRvdGFsU3VwcGx5QWRqdXN0ZWQgPSB0b3RhbFN1cHBseS5hZGQoQ3VycmVuY3lBbW91bnQuZnJvbVJhd0Ftb3VudCh0aGlzLmxpcXVpZGl0eVRva2VuLCBmZWVMaXF1aWRpdHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbFN1cHBseUFkanVzdGVkID0gdG90YWxTdXBwbHk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvdGFsU3VwcGx5QWRqdXN0ZWQgPSB0b3RhbFN1cHBseTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ3VycmVuY3lBbW91bnQuZnJvbVJhd0Ftb3VudCh0b2tlbiwgSlNCSS5kaXZpZGUoSlNCSS5tdWx0aXBseShsaXF1aWRpdHkucXVvdGllbnQsIHRoaXMucmVzZXJ2ZU9mKHRva2VuKS5xdW90aWVudCksIHRvdGFsU3VwcGx5QWRqdXN0ZWQucXVvdGllbnQpKTtcbiAgfTtcblxuICBfcHJvdG8uZGVyaXZlUGVyY2VudEFmdGVyU2VsbEZlZXMgPSBmdW5jdGlvbiBkZXJpdmVQZXJjZW50QWZ0ZXJTZWxsRmVlcyhpbnB1dEFtb3VudCkge1xuICAgIHZhciBzZWxsRmVlQmlwcyA9IHRoaXMudG9rZW4wLndyYXBwZWQuZXF1YWxzKGlucHV0QW1vdW50LndyYXBwZWQuY3VycmVuY3kpID8gdGhpcy50b2tlbjAud3JhcHBlZC5zZWxsRmVlQnBzIDogdGhpcy50b2tlbjEud3JhcHBlZC5zZWxsRmVlQnBzO1xuXG4gICAgaWYgKHNlbGxGZWVCaXBzICE9IG51bGwgJiYgc2VsbEZlZUJpcHMuZ3QoQmlnTnVtYmVyLmZyb20oMCkpKSB7XG4gICAgICByZXR1cm4gT05FX0hVTkRSRURfUEVSQ0VOVC5zdWJ0cmFjdChuZXcgUGVyY2VudChKU0JJLkJpZ0ludChzZWxsRmVlQmlwcykpLmRpdmlkZShCQVNJU19QT0lOVFMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFpFUk9fUEVSQ0VOVDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmRlcml2ZVBlcmNlbnRBZnRlckJ1eUZlZXMgPSBmdW5jdGlvbiBkZXJpdmVQZXJjZW50QWZ0ZXJCdXlGZWVzKG91dHB1dEFtb3VudCkge1xuICAgIHZhciBidXlGZWVCcHMgPSB0aGlzLnRva2VuMC53cmFwcGVkLmVxdWFscyhvdXRwdXRBbW91bnQud3JhcHBlZC5jdXJyZW5jeSkgPyB0aGlzLnRva2VuMC53cmFwcGVkLmJ1eUZlZUJwcyA6IHRoaXMudG9rZW4xLndyYXBwZWQuYnV5RmVlQnBzO1xuXG4gICAgaWYgKGJ1eUZlZUJwcyAhPSBudWxsICYmIGJ1eUZlZUJwcy5ndChCaWdOdW1iZXIuZnJvbSgwKSkpIHtcbiAgICAgIHJldHVybiBPTkVfSFVORFJFRF9QRVJDRU5ULnN1YnRyYWN0KG5ldyBQZXJjZW50KEpTQkkuQmlnSW50KGJ1eUZlZUJwcykpLmRpdmlkZShCQVNJU19QT0lOVFMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFpFUk9fUEVSQ0VOVDtcbiAgICB9XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFBhaXIsIFt7XG4gICAga2V5OiBcInRva2VuMFByaWNlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy50b2tlbkFtb3VudHNbMV0uZGl2aWRlKHRoaXMudG9rZW5BbW91bnRzWzBdKTtcbiAgICAgIHJldHVybiBuZXcgUHJpY2UodGhpcy50b2tlbjAsIHRoaXMudG9rZW4xLCByZXN1bHQuZGVub21pbmF0b3IsIHJlc3VsdC5udW1lcmF0b3IpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWlkIHByaWNlIG9mIHRoZSBwYWlyIGluIHRlcm1zIG9mIHRva2VuMSwgaS5lLiB0aGUgcmF0aW8gb2YgcmVzZXJ2ZTAgdG8gcmVzZXJ2ZTFcclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9rZW4xUHJpY2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnRva2VuQW1vdW50c1swXS5kaXZpZGUodGhpcy50b2tlbkFtb3VudHNbMV0pO1xuICAgICAgcmV0dXJuIG5ldyBQcmljZSh0aGlzLnRva2VuMSwgdGhpcy50b2tlbjAsIHJlc3VsdC5kZW5vbWluYXRvciwgcmVzdWx0Lm51bWVyYXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoYWluSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuMC5jaGFpbklkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2tlbjBcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuQW1vdW50c1swXS5jdXJyZW5jeTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9rZW4xXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbkFtb3VudHNbMV0uY3VycmVuY3k7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2VydmUwXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbkFtb3VudHNbMF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2VydmUxXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbkFtb3VudHNbMV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhaXI7XG59KCk7XG5cbnZhciBSb3V0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdXRlKHBhaXJzLCBpbnB1dCwgb3V0cHV0KSB7XG4gICAgdGhpcy5fbWlkUHJpY2UgPSBudWxsO1xuICAgICEocGFpcnMubGVuZ3RoID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdQQUlSUycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgY2hhaW5JZCA9IHBhaXJzWzBdLmNoYWluSWQ7XG4gICAgIXBhaXJzLmV2ZXJ5KGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICByZXR1cm4gcGFpci5jaGFpbklkID09PSBjaGFpbklkO1xuICAgIH0pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ0hBSU5fSURTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciB3cmFwcGVkSW5wdXQgPSBpbnB1dC53cmFwcGVkO1xuICAgICFwYWlyc1swXS5pbnZvbHZlc1Rva2VuKHdyYXBwZWRJbnB1dCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTlBVVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBvdXRwdXQgPT09ICd1bmRlZmluZWQnIHx8IHBhaXJzW3BhaXJzLmxlbmd0aCAtIDFdLmludm9sdmVzVG9rZW4ob3V0cHV0LndyYXBwZWQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ09VVFBVVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgcGF0aCA9IFt3cmFwcGVkSW5wdXRdO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShwYWlycy5lbnRyaWVzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3N0ZXAudmFsdWUsXG4gICAgICAgICAgaSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIHBhaXIgPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgIHZhciBjdXJyZW50SW5wdXQgPSBwYXRoW2ldO1xuICAgICAgIShjdXJyZW50SW5wdXQuZXF1YWxzKHBhaXIudG9rZW4wKSB8fCBjdXJyZW50SW5wdXQuZXF1YWxzKHBhaXIudG9rZW4xKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdQQVRIJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICB2YXIgX291dHB1dCA9IGN1cnJlbnRJbnB1dC5lcXVhbHMocGFpci50b2tlbjApID8gcGFpci50b2tlbjEgOiBwYWlyLnRva2VuMDtcblxuICAgICAgcGF0aC5wdXNoKF9vdXRwdXQpO1xuICAgIH1cblxuICAgIHRoaXMucGFpcnMgPSBwYWlycztcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSb3V0ZSwgW3tcbiAgICBrZXk6IFwibWlkUHJpY2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLl9taWRQcmljZSAhPT0gbnVsbCkgcmV0dXJuIHRoaXMuX21pZFByaWNlO1xuICAgICAgdmFyIHByaWNlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0aGlzLnBhaXJzLmVudHJpZXMoKSksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc3RlcDIudmFsdWUsXG4gICAgICAgICAgICBpID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgcGFpciA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICAgICAgcHJpY2VzLnB1c2godGhpcy5wYXRoW2ldLmVxdWFscyhwYWlyLnRva2VuMCkgPyBuZXcgUHJpY2UocGFpci5yZXNlcnZlMC5jdXJyZW5jeSwgcGFpci5yZXNlcnZlMS5jdXJyZW5jeSwgcGFpci5yZXNlcnZlMC5xdW90aWVudCwgcGFpci5yZXNlcnZlMS5xdW90aWVudCkgOiBuZXcgUHJpY2UocGFpci5yZXNlcnZlMS5jdXJyZW5jeSwgcGFpci5yZXNlcnZlMC5jdXJyZW5jeSwgcGFpci5yZXNlcnZlMS5xdW90aWVudCwgcGFpci5yZXNlcnZlMC5xdW90aWVudCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVkdWNlZCA9IHByaWNlcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yLm11bHRpcGx5KGN1cnJlbnRWYWx1ZSk7XG4gICAgICB9LCBwcmljZXNbMF0pO1xuICAgICAgcmV0dXJuIHRoaXMuX21pZFByaWNlID0gbmV3IFByaWNlKHRoaXMuaW5wdXQsIHRoaXMub3V0cHV0LCByZWR1Y2VkLmRlbm9taW5hdG9yLCByZWR1Y2VkLm51bWVyYXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoYWluSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhaXJzWzBdLmNoYWluSWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJvdXRlO1xufSgpO1xuXG4vLyBpbiBpbmNyZWFzaW5nIG9yZGVyLiBpLmUuIHRoZSBiZXN0IHRyYWRlcyBoYXZlIHRoZSBtb3N0IG91dHB1dHMgZm9yIHRoZSBsZWFzdCBpbnB1dHMgYW5kIGFyZSBzb3J0ZWQgZmlyc3RcblxuZnVuY3Rpb24gaW5wdXRPdXRwdXRDb21wYXJhdG9yKGEsIGIpIHtcbiAgLy8gbXVzdCBoYXZlIHNhbWUgaW5wdXQgYW5kIG91dHB1dCB0b2tlbiBmb3IgY29tcGFyaXNvblxuICAhYS5pbnB1dEFtb3VudC5jdXJyZW5jeS5lcXVhbHMoYi5pbnB1dEFtb3VudC5jdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTlBVVF9DVVJSRU5DWScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIWEub3V0cHV0QW1vdW50LmN1cnJlbmN5LmVxdWFscyhiLm91dHB1dEFtb3VudC5jdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdPVVRQVVRfQ1VSUkVOQ1knKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaWYgKGEub3V0cHV0QW1vdW50LmVxdWFsVG8oYi5vdXRwdXRBbW91bnQpKSB7XG4gICAgaWYgKGEuaW5wdXRBbW91bnQuZXF1YWxUbyhiLmlucHV0QW1vdW50KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSAvLyB0cmFkZSBBIHJlcXVpcmVzIGxlc3MgaW5wdXQgdGhhbiB0cmFkZSBCLCBzbyBBIHNob3VsZCBjb21lIGZpcnN0XG5cblxuICAgIGlmIChhLmlucHV0QW1vdW50Lmxlc3NUaGFuKGIuaW5wdXRBbW91bnQpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB0cmFkZUEgaGFzIGxlc3Mgb3V0cHV0IHRoYW4gdHJhZGUgQiwgc28gc2hvdWxkIGNvbWUgc2Vjb25kXG4gICAgaWYgKGEub3V0cHV0QW1vdW50Lmxlc3NUaGFuKGIub3V0cHV0QW1vdW50KSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbn0gLy8gZXh0ZW5zaW9uIG9mIHRoZSBpbnB1dCBvdXRwdXQgY29tcGFyYXRvciB0aGF0IGFsc28gY29uc2lkZXJzIG90aGVyIGRpbWVuc2lvbnMgb2YgdGhlIHRyYWRlIGluIHJhbmtpbmcgdGhlbVxuXG5mdW5jdGlvbiB0cmFkZUNvbXBhcmF0b3IoYSwgYikge1xuICB2YXIgaW9Db21wID0gaW5wdXRPdXRwdXRDb21wYXJhdG9yKGEsIGIpO1xuXG4gIGlmIChpb0NvbXAgIT09IDApIHtcbiAgICByZXR1cm4gaW9Db21wO1xuICB9IC8vIGNvbnNpZGVyIGxvd2VzdCBzbGlwcGFnZSBuZXh0LCBzaW5jZSB0aGVzZSBhcmUgbGVzcyBsaWtlbHkgdG8gZmFpbFxuXG5cbiAgaWYgKGEucHJpY2VJbXBhY3QubGVzc1RoYW4oYi5wcmljZUltcGFjdCkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYS5wcmljZUltcGFjdC5ncmVhdGVyVGhhbihiLnByaWNlSW1wYWN0KSkge1xuICAgIHJldHVybiAxO1xuICB9IC8vIGZpbmFsbHkgY29uc2lkZXIgdGhlIG51bWJlciBvZiBob3BzIHNpbmNlIGVhY2ggaG9wIGNvc3RzIGdhc1xuXG5cbiAgcmV0dXJuIGEucm91dGUucGF0aC5sZW5ndGggLSBiLnJvdXRlLnBhdGgubGVuZ3RoO1xufVxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSB0cmFkZSBleGVjdXRlZCBhZ2FpbnN0IGEgbGlzdCBvZiBwYWlycy5cclxuICogRG9lcyBub3QgYWNjb3VudCBmb3Igc2xpcHBhZ2UsIGkuZS4gdHJhZGVzIHRoYXQgZnJvbnQgcnVuIHRoaXMgdHJhZGUgYW5kIG1vdmUgdGhlIHByaWNlLlxyXG4gKi9cblxudmFyIFRyYWRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhZGUocm91dGUsIGFtb3VudCwgdHJhZGVUeXBlKSB7XG4gICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgIHRoaXMudHJhZGVUeXBlID0gdHJhZGVUeXBlO1xuICAgIHZhciB0b2tlbkFtb3VudHMgPSBuZXcgQXJyYXkocm91dGUucGF0aC5sZW5ndGgpO1xuXG4gICAgaWYgKHRyYWRlVHlwZSA9PT0gVHJhZGVUeXBlLkVYQUNUX0lOUFVUKSB7XG4gICAgICAhYW1vdW50LmN1cnJlbmN5LmVxdWFscyhyb3V0ZS5pbnB1dCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTlBVVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHRva2VuQW1vdW50c1swXSA9IGFtb3VudC53cmFwcGVkO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlLnBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBwYWlyID0gcm91dGUucGFpcnNbaV07XG5cbiAgICAgICAgdmFyIF9wYWlyJGdldE91dHB1dEFtb3VudCA9IHBhaXIuZ2V0T3V0cHV0QW1vdW50KHRva2VuQW1vdW50c1tpXSksXG4gICAgICAgICAgICBvdXRwdXRBbW91bnQgPSBfcGFpciRnZXRPdXRwdXRBbW91bnRbMF07XG5cbiAgICAgICAgdG9rZW5BbW91bnRzW2kgKyAxXSA9IG91dHB1dEFtb3VudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnB1dEFtb3VudCA9IEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHJvdXRlLmlucHV0LCBhbW91bnQubnVtZXJhdG9yLCBhbW91bnQuZGVub21pbmF0b3IpO1xuICAgICAgdGhpcy5vdXRwdXRBbW91bnQgPSBDdXJyZW5jeUFtb3VudC5mcm9tRnJhY3Rpb25hbEFtb3VudChyb3V0ZS5vdXRwdXQsIHRva2VuQW1vdW50c1t0b2tlbkFtb3VudHMubGVuZ3RoIC0gMV0ubnVtZXJhdG9yLCB0b2tlbkFtb3VudHNbdG9rZW5BbW91bnRzLmxlbmd0aCAtIDFdLmRlbm9taW5hdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIWFtb3VudC5jdXJyZW5jeS5lcXVhbHMocm91dGUub3V0cHV0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ09VVFBVVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHRva2VuQW1vdW50c1t0b2tlbkFtb3VudHMubGVuZ3RoIC0gMV0gPSBhbW91bnQud3JhcHBlZDtcblxuICAgICAgZm9yICh2YXIgX2kgPSByb3V0ZS5wYXRoLmxlbmd0aCAtIDE7IF9pID4gMDsgX2ktLSkge1xuICAgICAgICB2YXIgX3BhaXIgPSByb3V0ZS5wYWlyc1tfaSAtIDFdO1xuXG4gICAgICAgIHZhciBfcGFpciRnZXRJbnB1dEFtb3VudCA9IF9wYWlyLmdldElucHV0QW1vdW50KHRva2VuQW1vdW50c1tfaV0pLFxuICAgICAgICAgICAgaW5wdXRBbW91bnQgPSBfcGFpciRnZXRJbnB1dEFtb3VudFswXTtcblxuICAgICAgICB0b2tlbkFtb3VudHNbX2kgLSAxXSA9IGlucHV0QW1vdW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlucHV0QW1vdW50ID0gQ3VycmVuY3lBbW91bnQuZnJvbUZyYWN0aW9uYWxBbW91bnQocm91dGUuaW5wdXQsIHRva2VuQW1vdW50c1swXS5udW1lcmF0b3IsIHRva2VuQW1vdW50c1swXS5kZW5vbWluYXRvcik7XG4gICAgICB0aGlzLm91dHB1dEFtb3VudCA9IEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHJvdXRlLm91dHB1dCwgYW1vdW50Lm51bWVyYXRvciwgYW1vdW50LmRlbm9taW5hdG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4ZWN1dGlvblByaWNlID0gbmV3IFByaWNlKHRoaXMuaW5wdXRBbW91bnQuY3VycmVuY3ksIHRoaXMub3V0cHV0QW1vdW50LmN1cnJlbmN5LCB0aGlzLmlucHV0QW1vdW50LnF1b3RpZW50LCB0aGlzLm91dHB1dEFtb3VudC5xdW90aWVudCk7XG4gICAgdGhpcy5wcmljZUltcGFjdCA9IGNvbXB1dGVQcmljZUltcGFjdChyb3V0ZS5taWRQcmljZSwgdGhpcy5pbnB1dEFtb3VudCwgdGhpcy5vdXRwdXRBbW91bnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdHMgYW4gZXhhY3QgaW4gdHJhZGUgd2l0aCB0aGUgZ2l2ZW4gYW1vdW50IGluIGFuZCByb3V0ZVxyXG4gICAqIEBwYXJhbSByb3V0ZSByb3V0ZSBvZiB0aGUgZXhhY3QgaW4gdHJhZGVcclxuICAgKiBAcGFyYW0gYW1vdW50SW4gdGhlIGFtb3VudCBiZWluZyBwYXNzZWQgaW5cclxuICAgKi9cblxuXG4gIFRyYWRlLmV4YWN0SW4gPSBmdW5jdGlvbiBleGFjdEluKHJvdXRlLCBhbW91bnRJbikge1xuICAgIHJldHVybiBuZXcgVHJhZGUocm91dGUsIGFtb3VudEluLCBUcmFkZVR5cGUuRVhBQ1RfSU5QVVQpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdHMgYW4gZXhhY3Qgb3V0IHRyYWRlIHdpdGggdGhlIGdpdmVuIGFtb3VudCBvdXQgYW5kIHJvdXRlXHJcbiAgICogQHBhcmFtIHJvdXRlIHJvdXRlIG9mIHRoZSBleGFjdCBvdXQgdHJhZGVcclxuICAgKiBAcGFyYW0gYW1vdW50T3V0IHRoZSBhbW91bnQgcmV0dXJuZWQgYnkgdGhlIHRyYWRlXHJcbiAgICovXG4gIDtcblxuICBUcmFkZS5leGFjdE91dCA9IGZ1bmN0aW9uIGV4YWN0T3V0KHJvdXRlLCBhbW91bnRPdXQpIHtcbiAgICByZXR1cm4gbmV3IFRyYWRlKHJvdXRlLCBhbW91bnRPdXQsIFRyYWRlVHlwZS5FWEFDVF9PVVRQVVQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWluaW11bSBhbW91bnQgdGhhdCBtdXN0IGJlIHJlY2VpdmVkIGZyb20gdGhpcyB0cmFkZSBmb3IgdGhlIGdpdmVuIHNsaXBwYWdlIHRvbGVyYW5jZVxyXG4gICAqIEBwYXJhbSBzbGlwcGFnZVRvbGVyYW5jZSB0b2xlcmFuY2Ugb2YgdW5mYXZvcmFibGUgc2xpcHBhZ2UgZnJvbSB0aGUgZXhlY3V0aW9uIHByaWNlIG9mIHRoaXMgdHJhZGVcclxuICAgKi9cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBUcmFkZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm1pbmltdW1BbW91bnRPdXQgPSBmdW5jdGlvbiBtaW5pbXVtQW1vdW50T3V0KHNsaXBwYWdlVG9sZXJhbmNlKSB7XG4gICAgISFzbGlwcGFnZVRvbGVyYW5jZS5sZXNzVGhhbihaRVJPKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1NMSVBQQUdFX1RPTEVSQU5DRScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmICh0aGlzLnRyYWRlVHlwZSA9PT0gVHJhZGVUeXBlLkVYQUNUX09VVFBVVCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0QW1vdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2xpcHBhZ2VBZGp1c3RlZEFtb3VudE91dCA9IG5ldyBGcmFjdGlvbihPTkUpLmFkZChzbGlwcGFnZVRvbGVyYW5jZSkuaW52ZXJ0KCkubXVsdGlwbHkodGhpcy5vdXRwdXRBbW91bnQucXVvdGllbnQpLnF1b3RpZW50O1xuICAgICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQodGhpcy5vdXRwdXRBbW91bnQuY3VycmVuY3ksIHNsaXBwYWdlQWRqdXN0ZWRBbW91bnRPdXQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIG1heGltdW0gYW1vdW50IGluIHRoYXQgY2FuIGJlIHNwZW50IHZpYSB0aGlzIHRyYWRlIGZvciB0aGUgZ2l2ZW4gc2xpcHBhZ2UgdG9sZXJhbmNlXHJcbiAgICogQHBhcmFtIHNsaXBwYWdlVG9sZXJhbmNlIHRvbGVyYW5jZSBvZiB1bmZhdm9yYWJsZSBzbGlwcGFnZSBmcm9tIHRoZSBleGVjdXRpb24gcHJpY2Ugb2YgdGhpcyB0cmFkZVxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm1heGltdW1BbW91bnRJbiA9IGZ1bmN0aW9uIG1heGltdW1BbW91bnRJbihzbGlwcGFnZVRvbGVyYW5jZSkge1xuICAgICEhc2xpcHBhZ2VUb2xlcmFuY2UubGVzc1RoYW4oWkVSTykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdTTElQUEFHRV9UT0xFUkFOQ0UnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAodGhpcy50cmFkZVR5cGUgPT09IFRyYWRlVHlwZS5FWEFDVF9JTlBVVCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRBbW91bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzbGlwcGFnZUFkanVzdGVkQW1vdW50SW4gPSBuZXcgRnJhY3Rpb24oT05FKS5hZGQoc2xpcHBhZ2VUb2xlcmFuY2UpLm11bHRpcGx5KHRoaXMuaW5wdXRBbW91bnQucXVvdGllbnQpLnF1b3RpZW50O1xuICAgICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQodGhpcy5pbnB1dEFtb3VudC5jdXJyZW5jeSwgc2xpcHBhZ2VBZGp1c3RlZEFtb3VudEluKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBsaXN0IG9mIHBhaXJzLCBhbmQgYSBmaXhlZCBhbW91bnQgaW4sIHJldHVybnMgdGhlIHRvcCBgbWF4TnVtUmVzdWx0c2AgdHJhZGVzIHRoYXQgZ28gZnJvbSBhbiBpbnB1dCB0b2tlblxyXG4gICAqIGFtb3VudCB0byBhbiBvdXRwdXQgdG9rZW4sIG1ha2luZyBhdCBtb3N0IGBtYXhIb3BzYCBob3BzLlxyXG4gICAqIE5vdGUgdGhpcyBkb2VzIG5vdCBjb25zaWRlciBhZ2dyZWdhdGlvbiwgYXMgcm91dGVzIGFyZSBsaW5lYXIuIEl0J3MgcG9zc2libGUgYSBiZXR0ZXIgcm91dGUgZXhpc3RzIGJ5IHNwbGl0dGluZ1xyXG4gICAqIHRoZSBhbW91bnQgaW4gYW1vbmcgbXVsdGlwbGUgcm91dGVzLlxyXG4gICAqIEBwYXJhbSBwYWlycyB0aGUgcGFpcnMgdG8gY29uc2lkZXIgaW4gZmluZGluZyB0aGUgYmVzdCB0cmFkZVxyXG4gICAqIEBwYXJhbSBuZXh0QW1vdW50SW4gZXhhY3QgYW1vdW50IG9mIGlucHV0IGN1cnJlbmN5IHRvIHNwZW5kXHJcbiAgICogQHBhcmFtIGN1cnJlbmN5T3V0IHRoZSBkZXNpcmVkIGN1cnJlbmN5IG91dFxyXG4gICAqIEBwYXJhbSBtYXhOdW1SZXN1bHRzIG1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuXHJcbiAgICogQHBhcmFtIG1heEhvcHMgbWF4aW11bSBudW1iZXIgb2YgaG9wcyBhIHJldHVybmVkIHRyYWRlIGNhbiBtYWtlLCBlLmcuIDEgaG9wIGdvZXMgdGhyb3VnaCBhIHNpbmdsZSBwYWlyXHJcbiAgICogQHBhcmFtIGN1cnJlbnRQYWlycyB1c2VkIGluIHJlY3Vyc2lvbjsgdGhlIGN1cnJlbnQgbGlzdCBvZiBwYWlyc1xyXG4gICAqIEBwYXJhbSBjdXJyZW5jeUFtb3VudEluIHVzZWQgaW4gcmVjdXJzaW9uOyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGN1cnJlbmN5QW1vdW50SW4gcGFyYW1ldGVyXHJcbiAgICogQHBhcmFtIGJlc3RUcmFkZXMgdXNlZCBpbiByZWN1cnNpb247IHRoZSBjdXJyZW50IGxpc3Qgb2YgYmVzdCB0cmFkZXNcclxuICAgKi9cbiAgO1xuXG4gIFRyYWRlLmJlc3RUcmFkZUV4YWN0SW4gPSBmdW5jdGlvbiBiZXN0VHJhZGVFeGFjdEluKHBhaXJzLCBjdXJyZW5jeUFtb3VudEluLCBjdXJyZW5jeU91dCwgX3RlbXAsIC8vIHVzZWQgaW4gcmVjdXJzaW9uLlxuICBjdXJyZW50UGFpcnMsIG5leHRBbW91bnRJbiwgYmVzdFRyYWRlcykge1xuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIF9yZWYkbWF4TnVtUmVzdWx0cyA9IF9yZWYubWF4TnVtUmVzdWx0cyxcbiAgICAgICAgbWF4TnVtUmVzdWx0cyA9IF9yZWYkbWF4TnVtUmVzdWx0cyA9PT0gdm9pZCAwID8gMyA6IF9yZWYkbWF4TnVtUmVzdWx0cyxcbiAgICAgICAgX3JlZiRtYXhIb3BzID0gX3JlZi5tYXhIb3BzLFxuICAgICAgICBtYXhIb3BzID0gX3JlZiRtYXhIb3BzID09PSB2b2lkIDAgPyAzIDogX3JlZiRtYXhIb3BzO1xuXG4gICAgaWYgKGN1cnJlbnRQYWlycyA9PT0gdm9pZCAwKSB7XG4gICAgICBjdXJyZW50UGFpcnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAobmV4dEFtb3VudEluID09PSB2b2lkIDApIHtcbiAgICAgIG5leHRBbW91bnRJbiA9IGN1cnJlbmN5QW1vdW50SW47XG4gICAgfVxuXG4gICAgaWYgKGJlc3RUcmFkZXMgPT09IHZvaWQgMCkge1xuICAgICAgYmVzdFRyYWRlcyA9IFtdO1xuICAgIH1cblxuICAgICEocGFpcnMubGVuZ3RoID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdQQUlSUycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKG1heEhvcHMgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ01BWF9IT1BTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEoY3VycmVuY3lBbW91bnRJbiA9PT0gbmV4dEFtb3VudEluIHx8IGN1cnJlbnRQYWlycy5sZW5ndGggPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0lOVkFMSURfUkVDVVJTSU9OJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBhbW91bnRJbiA9IG5leHRBbW91bnRJbi53cmFwcGVkO1xuICAgIHZhciB0b2tlbk91dCA9IGN1cnJlbmN5T3V0LndyYXBwZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFpciA9IHBhaXJzW2ldOyAvLyBwYWlyIGlycmVsZXZhbnRcblxuICAgICAgaWYgKCFwYWlyLnRva2VuMC5lcXVhbHMoYW1vdW50SW4uY3VycmVuY3kpICYmICFwYWlyLnRva2VuMS5lcXVhbHMoYW1vdW50SW4uY3VycmVuY3kpKSBjb250aW51ZTtcbiAgICAgIGlmIChwYWlyLnJlc2VydmUwLmVxdWFsVG8oWkVSTykgfHwgcGFpci5yZXNlcnZlMS5lcXVhbFRvKFpFUk8pKSBjb250aW51ZTtcbiAgICAgIHZhciBhbW91bnRPdXQgPSB2b2lkIDA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIDtcblxuICAgICAgICB2YXIgX3BhaXIkZ2V0T3V0cHV0QW1vdW50MiA9IHBhaXIuZ2V0T3V0cHV0QW1vdW50KGFtb3VudEluKTtcblxuICAgICAgICBhbW91bnRPdXQgPSBfcGFpciRnZXRPdXRwdXRBbW91bnQyWzBdO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gaW5wdXQgdG9vIGxvd1xuICAgICAgICBpZiAoZXJyb3IuaXNJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gLy8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBvdXRwdXQgdG9rZW4sIHNvIHRoaXMgaXMgdGhlIGZpbmFsIHRyYWRlIG9mIG9uZSBvZiB0aGUgcGF0aHNcblxuXG4gICAgICBpZiAoYW1vdW50T3V0LmN1cnJlbmN5LmVxdWFscyh0b2tlbk91dCkpIHtcbiAgICAgICAgc29ydGVkSW5zZXJ0KGJlc3RUcmFkZXMsIG5ldyBUcmFkZShuZXcgUm91dGUoW10uY29uY2F0KGN1cnJlbnRQYWlycywgW3BhaXJdKSwgY3VycmVuY3lBbW91bnRJbi5jdXJyZW5jeSwgY3VycmVuY3lPdXQpLCBjdXJyZW5jeUFtb3VudEluLCBUcmFkZVR5cGUuRVhBQ1RfSU5QVVQpLCBtYXhOdW1SZXN1bHRzLCB0cmFkZUNvbXBhcmF0b3IpO1xuICAgICAgfSBlbHNlIGlmIChtYXhIb3BzID4gMSAmJiBwYWlycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBwYWlyc0V4Y2x1ZGluZ1RoaXNQYWlyID0gcGFpcnMuc2xpY2UoMCwgaSkuY29uY2F0KHBhaXJzLnNsaWNlKGkgKyAxLCBwYWlycy5sZW5ndGgpKTsgLy8gb3RoZXJ3aXNlLCBjb25zaWRlciBhbGwgdGhlIG90aGVyIHBhdGhzIHRoYXQgbGVhZCBmcm9tIHRoaXMgdG9rZW4gYXMgbG9uZyBhcyB3ZSBoYXZlIG5vdCBleGNlZWRlZCBtYXhIb3BzXG5cbiAgICAgICAgVHJhZGUuYmVzdFRyYWRlRXhhY3RJbihwYWlyc0V4Y2x1ZGluZ1RoaXNQYWlyLCBjdXJyZW5jeUFtb3VudEluLCBjdXJyZW5jeU91dCwge1xuICAgICAgICAgIG1heE51bVJlc3VsdHM6IG1heE51bVJlc3VsdHMsXG4gICAgICAgICAgbWF4SG9wczogbWF4SG9wcyAtIDFcbiAgICAgICAgfSwgW10uY29uY2F0KGN1cnJlbnRQYWlycywgW3BhaXJdKSwgYW1vdW50T3V0LCBiZXN0VHJhZGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdFRyYWRlcztcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGV4ZWN1dGlvbiBwcmljZSBhZnRlciBhY2NvdW50aW5nIGZvciBzbGlwcGFnZSB0b2xlcmFuY2VcclxuICAgKiBAcGFyYW0gc2xpcHBhZ2VUb2xlcmFuY2UgdGhlIGFsbG93ZWQgdG9sZXJhdGVkIHNsaXBwYWdlXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ud29yc3RFeGVjdXRpb25QcmljZSA9IGZ1bmN0aW9uIHdvcnN0RXhlY3V0aW9uUHJpY2Uoc2xpcHBhZ2VUb2xlcmFuY2UpIHtcbiAgICByZXR1cm4gbmV3IFByaWNlKHRoaXMuaW5wdXRBbW91bnQuY3VycmVuY3ksIHRoaXMub3V0cHV0QW1vdW50LmN1cnJlbmN5LCB0aGlzLm1heGltdW1BbW91bnRJbihzbGlwcGFnZVRvbGVyYW5jZSkucXVvdGllbnQsIHRoaXMubWluaW11bUFtb3VudE91dChzbGlwcGFnZVRvbGVyYW5jZSkucXVvdGllbnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIHNpbWlsYXIgdG8gdGhlIGFib3ZlIG1ldGhvZCBidXQgaW5zdGVhZCB0YXJnZXRzIGEgZml4ZWQgb3V0cHV0IGFtb3VudFxyXG4gICAqIGdpdmVuIGEgbGlzdCBvZiBwYWlycywgYW5kIGEgZml4ZWQgYW1vdW50IG91dCwgcmV0dXJucyB0aGUgdG9wIGBtYXhOdW1SZXN1bHRzYCB0cmFkZXMgdGhhdCBnbyBmcm9tIGFuIGlucHV0IHRva2VuXHJcbiAgICogdG8gYW4gb3V0cHV0IHRva2VuIGFtb3VudCwgbWFraW5nIGF0IG1vc3QgYG1heEhvcHNgIGhvcHNcclxuICAgKiBub3RlIHRoaXMgZG9lcyBub3QgY29uc2lkZXIgYWdncmVnYXRpb24sIGFzIHJvdXRlcyBhcmUgbGluZWFyLiBpdCdzIHBvc3NpYmxlIGEgYmV0dGVyIHJvdXRlIGV4aXN0cyBieSBzcGxpdHRpbmdcclxuICAgKiB0aGUgYW1vdW50IGluIGFtb25nIG11bHRpcGxlIHJvdXRlcy5cclxuICAgKiBAcGFyYW0gcGFpcnMgdGhlIHBhaXJzIHRvIGNvbnNpZGVyIGluIGZpbmRpbmcgdGhlIGJlc3QgdHJhZGVcclxuICAgKiBAcGFyYW0gY3VycmVuY3lJbiB0aGUgY3VycmVuY3kgdG8gc3BlbmRcclxuICAgKiBAcGFyYW0gbmV4dEFtb3VudE91dCB0aGUgZXhhY3QgYW1vdW50IG9mIGN1cnJlbmN5IG91dFxyXG4gICAqIEBwYXJhbSBtYXhOdW1SZXN1bHRzIG1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuXHJcbiAgICogQHBhcmFtIG1heEhvcHMgbWF4aW11bSBudW1iZXIgb2YgaG9wcyBhIHJldHVybmVkIHRyYWRlIGNhbiBtYWtlLCBlLmcuIDEgaG9wIGdvZXMgdGhyb3VnaCBhIHNpbmdsZSBwYWlyXHJcbiAgICogQHBhcmFtIGN1cnJlbnRQYWlycyB1c2VkIGluIHJlY3Vyc2lvbjsgdGhlIGN1cnJlbnQgbGlzdCBvZiBwYWlyc1xyXG4gICAqIEBwYXJhbSBjdXJyZW5jeUFtb3VudE91dCB1c2VkIGluIHJlY3Vyc2lvbjsgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBjdXJyZW5jeUFtb3VudE91dCBwYXJhbWV0ZXJcclxuICAgKiBAcGFyYW0gYmVzdFRyYWRlcyB1c2VkIGluIHJlY3Vyc2lvbjsgdGhlIGN1cnJlbnQgbGlzdCBvZiBiZXN0IHRyYWRlc1xyXG4gICAqL1xuICA7XG5cbiAgVHJhZGUuYmVzdFRyYWRlRXhhY3RPdXQgPSBmdW5jdGlvbiBiZXN0VHJhZGVFeGFjdE91dChwYWlycywgY3VycmVuY3lJbiwgY3VycmVuY3lBbW91bnRPdXQsIF90ZW1wMiwgLy8gdXNlZCBpbiByZWN1cnNpb24uXG4gIGN1cnJlbnRQYWlycywgbmV4dEFtb3VudE91dCwgYmVzdFRyYWRlcykge1xuICAgIHZhciBfcmVmMiA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsXG4gICAgICAgIF9yZWYyJG1heE51bVJlc3VsdHMgPSBfcmVmMi5tYXhOdW1SZXN1bHRzLFxuICAgICAgICBtYXhOdW1SZXN1bHRzID0gX3JlZjIkbWF4TnVtUmVzdWx0cyA9PT0gdm9pZCAwID8gMyA6IF9yZWYyJG1heE51bVJlc3VsdHMsXG4gICAgICAgIF9yZWYyJG1heEhvcHMgPSBfcmVmMi5tYXhIb3BzLFxuICAgICAgICBtYXhIb3BzID0gX3JlZjIkbWF4SG9wcyA9PT0gdm9pZCAwID8gMyA6IF9yZWYyJG1heEhvcHM7XG5cbiAgICBpZiAoY3VycmVudFBhaXJzID09PSB2b2lkIDApIHtcbiAgICAgIGN1cnJlbnRQYWlycyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChuZXh0QW1vdW50T3V0ID09PSB2b2lkIDApIHtcbiAgICAgIG5leHRBbW91bnRPdXQgPSBjdXJyZW5jeUFtb3VudE91dDtcbiAgICB9XG5cbiAgICBpZiAoYmVzdFRyYWRlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBiZXN0VHJhZGVzID0gW107XG4gICAgfVxuXG4gICAgIShwYWlycy5sZW5ndGggPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1BBSVJTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEobWF4SG9wcyA+IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTUFYX0hPUFMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIShjdXJyZW5jeUFtb3VudE91dCA9PT0gbmV4dEFtb3VudE91dCB8fCBjdXJyZW50UGFpcnMubGVuZ3RoID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTlZBTElEX1JFQ1VSU0lPTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgYW1vdW50T3V0ID0gbmV4dEFtb3VudE91dC53cmFwcGVkO1xuICAgIHZhciB0b2tlbkluID0gY3VycmVuY3lJbi53cmFwcGVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXTsgLy8gcGFpciBpcnJlbGV2YW50XG5cbiAgICAgIGlmICghcGFpci50b2tlbjAuZXF1YWxzKGFtb3VudE91dC5jdXJyZW5jeSkgJiYgIXBhaXIudG9rZW4xLmVxdWFscyhhbW91bnRPdXQuY3VycmVuY3kpKSBjb250aW51ZTtcbiAgICAgIGlmIChwYWlyLnJlc2VydmUwLmVxdWFsVG8oWkVSTykgfHwgcGFpci5yZXNlcnZlMS5lcXVhbFRvKFpFUk8pKSBjb250aW51ZTtcbiAgICAgIHZhciBhbW91bnRJbiA9IHZvaWQgMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgO1xuXG4gICAgICAgIHZhciBfcGFpciRnZXRJbnB1dEFtb3VudDIgPSBwYWlyLmdldElucHV0QW1vdW50KGFtb3VudE91dCk7XG5cbiAgICAgICAgYW1vdW50SW4gPSBfcGFpciRnZXRJbnB1dEFtb3VudDJbMF07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBub3QgZW5vdWdoIGxpcXVpZGl0eSBpbiB0aGlzIHBhaXJcbiAgICAgICAgaWYgKGVycm9yLmlzSW5zdWZmaWNpZW50UmVzZXJ2ZXNFcnJvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgaW5wdXQgdG9rZW4sIHNvIHRoaXMgaXMgdGhlIGZpcnN0IHRyYWRlIG9mIG9uZSBvZiB0aGUgcGF0aHNcblxuXG4gICAgICBpZiAoYW1vdW50SW4uY3VycmVuY3kuZXF1YWxzKHRva2VuSW4pKSB7XG4gICAgICAgIHNvcnRlZEluc2VydChiZXN0VHJhZGVzLCBuZXcgVHJhZGUobmV3IFJvdXRlKFtwYWlyXS5jb25jYXQoY3VycmVudFBhaXJzKSwgY3VycmVuY3lJbiwgY3VycmVuY3lBbW91bnRPdXQuY3VycmVuY3kpLCBjdXJyZW5jeUFtb3VudE91dCwgVHJhZGVUeXBlLkVYQUNUX09VVFBVVCksIG1heE51bVJlc3VsdHMsIHRyYWRlQ29tcGFyYXRvcik7XG4gICAgICB9IGVsc2UgaWYgKG1heEhvcHMgPiAxICYmIHBhaXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIHBhaXJzRXhjbHVkaW5nVGhpc1BhaXIgPSBwYWlycy5zbGljZSgwLCBpKS5jb25jYXQocGFpcnMuc2xpY2UoaSArIDEsIHBhaXJzLmxlbmd0aCkpOyAvLyBvdGhlcndpc2UsIGNvbnNpZGVyIGFsbCB0aGUgb3RoZXIgcGF0aHMgdGhhdCBhcnJpdmUgYXQgdGhpcyB0b2tlbiBhcyBsb25nIGFzIHdlIGhhdmUgbm90IGV4Y2VlZGVkIG1heEhvcHNcblxuICAgICAgICBUcmFkZS5iZXN0VHJhZGVFeGFjdE91dChwYWlyc0V4Y2x1ZGluZ1RoaXNQYWlyLCBjdXJyZW5jeUluLCBjdXJyZW5jeUFtb3VudE91dCwge1xuICAgICAgICAgIG1heE51bVJlc3VsdHM6IG1heE51bVJlc3VsdHMsXG4gICAgICAgICAgbWF4SG9wczogbWF4SG9wcyAtIDFcbiAgICAgICAgfSwgW3BhaXJdLmNvbmNhdChjdXJyZW50UGFpcnMpLCBhbW91bnRJbiwgYmVzdFRyYWRlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3RUcmFkZXM7XG4gIH07XG5cbiAgcmV0dXJuIFRyYWRlO1xufSgpO1xuXG5mdW5jdGlvbiB0b0hleChjdXJyZW5jeUFtb3VudCkge1xuICByZXR1cm4gXCIweFwiICsgY3VycmVuY3lBbW91bnQucXVvdGllbnQudG9TdHJpbmcoMTYpO1xufVxuXG52YXIgWkVST19IRVggPSAnMHgwJztcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBVbmlzd2FwIFYyIFJvdXRlciwgYW5kIGhhcyBzdGF0aWMgbWV0aG9kcyBmb3IgaGVscGluZyBleGVjdXRlIHRyYWRlcy5cclxuICovXG5cbnZhciBSb3V0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDYW5ub3QgYmUgY29uc3RydWN0ZWQuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJvdXRlcigpIHt9XG4gIC8qKlxyXG4gICAqIFByb2R1Y2VzIHRoZSBvbi1jaGFpbiBtZXRob2QgbmFtZSB0byBjYWxsIGFuZCB0aGUgaGV4IGVuY29kZWQgcGFyYW1ldGVycyB0byBwYXNzIGFzIGFyZ3VtZW50cyBmb3IgYSBnaXZlbiB0cmFkZS5cclxuICAgKiBAcGFyYW0gdHJhZGUgdG8gcHJvZHVjZSBjYWxsIHBhcmFtZXRlcnMgZm9yXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyBmb3IgdGhlIGNhbGwgcGFyYW1ldGVyc1xyXG4gICAqL1xuXG5cbiAgUm91dGVyLnN3YXBDYWxsUGFyYW1ldGVycyA9IGZ1bmN0aW9uIHN3YXBDYWxsUGFyYW1ldGVycyh0cmFkZSwgb3B0aW9ucykge1xuICAgIHZhciBldGhlckluID0gdHJhZGUuaW5wdXRBbW91bnQuY3VycmVuY3kuaXNOYXRpdmU7XG4gICAgdmFyIGV0aGVyT3V0ID0gdHJhZGUub3V0cHV0QW1vdW50LmN1cnJlbmN5LmlzTmF0aXZlOyAvLyB0aGUgcm91dGVyIGRvZXMgbm90IHN1cHBvcnQgYm90aCBldGhlciBpbiBhbmQgb3V0XG5cbiAgICAhIShldGhlckluICYmIGV0aGVyT3V0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0VUSEVSX0lOX09VVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKCEoJ3R0bCcgaW4gb3B0aW9ucykgfHwgb3B0aW9ucy50dGwgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1RUTCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgdG8gPSB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyhvcHRpb25zLnJlY2lwaWVudCk7XG4gICAgdmFyIGFtb3VudEluID0gdG9IZXgodHJhZGUubWF4aW11bUFtb3VudEluKG9wdGlvbnMuYWxsb3dlZFNsaXBwYWdlKSk7XG4gICAgdmFyIGFtb3VudE91dCA9IHRvSGV4KHRyYWRlLm1pbmltdW1BbW91bnRPdXQob3B0aW9ucy5hbGxvd2VkU2xpcHBhZ2UpKTtcbiAgICB2YXIgcGF0aCA9IHRyYWRlLnJvdXRlLnBhdGgubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLmFkZHJlc3M7XG4gICAgfSk7XG4gICAgdmFyIGRlYWRsaW5lID0gJ3R0bCcgaW4gb3B0aW9ucyA/IFwiMHhcIiArIChNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyBvcHRpb25zLnR0bCkudG9TdHJpbmcoMTYpIDogXCIweFwiICsgb3B0aW9ucy5kZWFkbGluZS50b1N0cmluZygxNik7XG4gICAgdmFyIHVzZUZlZU9uVHJhbnNmZXIgPSBCb29sZWFuKG9wdGlvbnMuZmVlT25UcmFuc2Zlcik7XG4gICAgdmFyIG1ldGhvZE5hbWU7XG4gICAgdmFyIGFyZ3M7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgc3dpdGNoICh0cmFkZS50cmFkZVR5cGUpIHtcbiAgICAgIGNhc2UgVHJhZGVUeXBlLkVYQUNUX0lOUFVUOlxuICAgICAgICBpZiAoZXRoZXJJbikge1xuICAgICAgICAgIG1ldGhvZE5hbWUgPSB1c2VGZWVPblRyYW5zZmVyID8gJ3N3YXBFeGFjdEVUSEZvclRva2Vuc1N1cHBvcnRpbmdGZWVPblRyYW5zZmVyVG9rZW5zJyA6ICdzd2FwRXhhY3RFVEhGb3JUb2tlbnMnOyAvLyAodWludCBhbW91bnRPdXRNaW4sIGFkZHJlc3NbXSBjYWxsZGF0YSBwYXRoLCBhZGRyZXNzIHRvLCB1aW50IGRlYWRsaW5lKVxuXG4gICAgICAgICAgYXJncyA9IFthbW91bnRPdXQsIHBhdGgsIHRvLCBkZWFkbGluZV07XG4gICAgICAgICAgdmFsdWUgPSBhbW91bnRJbjtcbiAgICAgICAgfSBlbHNlIGlmIChldGhlck91dCkge1xuICAgICAgICAgIG1ldGhvZE5hbWUgPSB1c2VGZWVPblRyYW5zZmVyID8gJ3N3YXBFeGFjdFRva2Vuc0ZvckVUSFN1cHBvcnRpbmdGZWVPblRyYW5zZmVyVG9rZW5zJyA6ICdzd2FwRXhhY3RUb2tlbnNGb3JFVEgnOyAvLyAodWludCBhbW91bnRJbiwgdWludCBhbW91bnRPdXRNaW4sIGFkZHJlc3NbXSBjYWxsZGF0YSBwYXRoLCBhZGRyZXNzIHRvLCB1aW50IGRlYWRsaW5lKVxuXG4gICAgICAgICAgYXJncyA9IFthbW91bnRJbiwgYW1vdW50T3V0LCBwYXRoLCB0bywgZGVhZGxpbmVdO1xuICAgICAgICAgIHZhbHVlID0gWkVST19IRVg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0aG9kTmFtZSA9IHVzZUZlZU9uVHJhbnNmZXIgPyAnc3dhcEV4YWN0VG9rZW5zRm9yVG9rZW5zU3VwcG9ydGluZ0ZlZU9uVHJhbnNmZXJUb2tlbnMnIDogJ3N3YXBFeGFjdFRva2Vuc0ZvclRva2Vucyc7IC8vICh1aW50IGFtb3VudEluLCB1aW50IGFtb3VudE91dE1pbiwgYWRkcmVzc1tdIGNhbGxkYXRhIHBhdGgsIGFkZHJlc3MgdG8sIHVpbnQgZGVhZGxpbmUpXG5cbiAgICAgICAgICBhcmdzID0gW2Ftb3VudEluLCBhbW91bnRPdXQsIHBhdGgsIHRvLCBkZWFkbGluZV07XG4gICAgICAgICAgdmFsdWUgPSBaRVJPX0hFWDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRyYWRlVHlwZS5FWEFDVF9PVVRQVVQ6XG4gICAgICAgICEhdXNlRmVlT25UcmFuc2ZlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0VYQUNUX09VVF9GT1QnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGV0aGVySW4pIHtcbiAgICAgICAgICBtZXRob2ROYW1lID0gJ3N3YXBFVEhGb3JFeGFjdFRva2Vucyc7IC8vICh1aW50IGFtb3VudE91dCwgYWRkcmVzc1tdIGNhbGxkYXRhIHBhdGgsIGFkZHJlc3MgdG8sIHVpbnQgZGVhZGxpbmUpXG5cbiAgICAgICAgICBhcmdzID0gW2Ftb3VudE91dCwgcGF0aCwgdG8sIGRlYWRsaW5lXTtcbiAgICAgICAgICB2YWx1ZSA9IGFtb3VudEluO1xuICAgICAgICB9IGVsc2UgaWYgKGV0aGVyT3V0KSB7XG4gICAgICAgICAgbWV0aG9kTmFtZSA9ICdzd2FwVG9rZW5zRm9yRXhhY3RFVEgnOyAvLyAodWludCBhbW91bnRPdXQsIHVpbnQgYW1vdW50SW5NYXgsIGFkZHJlc3NbXSBjYWxsZGF0YSBwYXRoLCBhZGRyZXNzIHRvLCB1aW50IGRlYWRsaW5lKVxuXG4gICAgICAgICAgYXJncyA9IFthbW91bnRPdXQsIGFtb3VudEluLCBwYXRoLCB0bywgZGVhZGxpbmVdO1xuICAgICAgICAgIHZhbHVlID0gWkVST19IRVg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0aG9kTmFtZSA9ICdzd2FwVG9rZW5zRm9yRXhhY3RUb2tlbnMnOyAvLyAodWludCBhbW91bnRPdXQsIHVpbnQgYW1vdW50SW5NYXgsIGFkZHJlc3NbXSBjYWxsZGF0YSBwYXRoLCBhZGRyZXNzIHRvLCB1aW50IGRlYWRsaW5lKVxuXG4gICAgICAgICAgYXJncyA9IFthbW91bnRPdXQsIGFtb3VudEluLCBwYXRoLCB0bywgZGVhZGxpbmVdO1xuICAgICAgICAgIHZhbHVlID0gWkVST19IRVg7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KCk7XG5cbmV4cG9ydCB7IEZBQ1RPUllfQUREUkVTU19NQVAsIElOSVRfQ09ERV9IQVNILCBJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yLCBJbnN1ZmZpY2llbnRSZXNlcnZlc0Vycm9yLCBNSU5JTVVNX0xJUVVJRElUWSwgUGFpciwgUm91dGUsIFJvdXRlciwgVHJhZGUsIGNvbXB1dGVQYWlyQWRkcmVzcywgaW5wdXRPdXRwdXRDb21wYXJhdG9yLCB0cmFkZUNvbXBhcmF0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXYyLXNkay5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@uniswap+v2-sdk@3.3.0/node_modules/@uniswap/v2-sdk/dist/v2-sdk.esm.js\n");

/***/ })

};
;